// Code generated by 'gofp'. DO NOT EDIT.
package strava
import "reflect" 
import "sort" 
import "sync" 
import "time"
import "github.com/logic-building/functional-go/fp" 

func MapActivity(f func(Activity) Activity, list []Activity) []Activity {
	if f == nil {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

func MapActivityPtr(f func(*Activity) *Activity, list []*Activity) []*Activity {
	if f == nil {
		return []*Activity{}
	}
	newList := make([]*Activity, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapActivityPtrErr takes 2 arguments:
//  1. A function input argument: *Activity and return types (*Activity, error)
//  2. A list of type []*Activity
//
// Returns:
// 	([]*Activity, error)
func MapActivityPtrErr(f func(*Activity) (*Activity, error), list []*Activity) ([]*Activity, error) {
	if f == nil {
		return []*Activity{}, nil
	}
	newList := make([]*Activity, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

// MapActivityErr takes 2 arguments:
//  1. A function input argument: Activity and return types (Activity, error)
//  2. A list of type []Activity
//
// Returns:
// 	([]Activity, error)
func MapActivityErr(f func(Activity) (Activity, error), list []Activity) ([]Activity, error) {
	if f == nil {
		return []Activity{}, nil
	}
	newList := make([]Activity, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

func FilterActivity(f func(Activity) bool, list []Activity) []Activity {
	if f == nil {
		return []Activity{}
	}
	var newList []Activity
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func FilterActivityPtr(f func(*Activity) bool, list []*Activity) []*Activity {
	if f == nil {
		return []*Activity{}
	}
	var newList []*Activity
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// FilterActivityPtrErr takes two arguments
//  1. Function: takes 1 argument of type Activity and returns (bool, error)
//  2. slice of type []*Activity
//
// Returns:
//  new filtered list and error
func FilterActivityPtrErr(f func(*Activity) (bool, error), list []*Activity) ([]*Activity, error) {
	if f == nil {
		return []*Activity{}, nil
	}
	var newList []*Activity
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// FilterActivityErr takes two arguments
//  1. Function: takes 1 argument of type Activity and returns (bool, error)
//  2. slice of type []Activity
//
// Returns:
//  new filtered list and error
func FilterActivityErr(f func(Activity) (bool, error), list []Activity) ([]Activity, error) {
	if f == nil {
		return []Activity{}, nil
	}
	var newList []Activity
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func RemoveActivity(f func(Activity) bool, list []Activity) []Activity {
	if f == nil {
		return []Activity{}
	}
	var newList []Activity
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func RemoveActivityPtr(f func(*Activity) bool, list []*Activity) []*Activity {
	if f == nil {
		return []*Activity{}
	}
	var newList []*Activity
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// RemoveActivityPtrErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type *Activity and return types(bool, error)
//	2. List of type: []*Activity
//
// Returns:
//	New list and error: ([]*Activity, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveActivityPtrErr(f func(*Activity) (bool, error), list []*Activity) ([]*Activity, error) {
	if f == nil {
		return []*Activity{}, nil
	}
	var newList []*Activity
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// RemoveActivityErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type Activity and return types(bool, error)
//	2. List of type: []Activity
//
// Returns:
//	New list and error: ([]Activity, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveActivityErr(f func(Activity) (bool, error), list []Activity) ([]Activity, error) {
	if f == nil {
		return []Activity{}, nil
	}
	var newList []Activity
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func SomeActivity(f func(Activity) bool, list []Activity) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

func SomeActivityPtr(f func(*Activity) bool, list []*Activity) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

// SomeActivityPtrErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeActivityPtrErr(f func(*Activity) (bool, error), list []*Activity) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

// SomeActivityErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeActivityErr(f func(Activity) (bool, error), list []Activity) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

func EveryActivity(f func(Activity) bool, list []Activity) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

func EveryActivityPtr(f func(*Activity) bool, list []*Activity) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

// EveryActivityPtrErr returns true if supplied function returns logical true for every item in the list
func EveryActivityPtrErr(f func(*Activity) (bool, error), list []*Activity) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

// EveryActivityErr returns true if supplied function returns logical true for every item in the list
func EveryActivityErr(f func(Activity) (bool, error), list []Activity) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

func DropWhileActivity(f func(Activity) bool, list []Activity) []Activity {
	if f == nil {
		return []Activity{}
	}
	var newList []Activity
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]Activity, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

func DropWhileActivityPtr(f func(*Activity) bool, list []*Activity) []*Activity {
	if f == nil {
		return []*Activity{}
	}
	var newList []*Activity
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]*Activity, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

// DropWhileActivityPtrErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhileActivityPtrErr(f func(*Activity) (bool, error), list []*Activity) ([]*Activity, error) {
	if f == nil {
		return []*Activity{}, nil
	}
	var newList []*Activity
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]*Activity, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

// DropWhileActivityErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhileActivityErr(f func(Activity) (bool, error), list []Activity) ([]Activity, error) {
	if f == nil {
		return []Activity{}, nil
	}
	var newList []Activity
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]Activity, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

func TakeWhileActivity(f func(Activity) bool, list []Activity) []Activity {
	if f == nil {
		return []Activity{}
	}
	var newList []Activity
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

func TakeWhileActivityPtr(f func(*Activity) bool, list []*Activity) []*Activity {
	if f == nil {
		return []*Activity{}
	}
	var newList []*Activity
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

// TakeWhileActivityPtrErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type *Activity and returns ([]*Activity, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileActivityPtrErr(f func(*Activity) (bool, error), list []*Activity) ([]*Activity, error) {
	if f == nil {
		return []*Activity{}, nil
	}
	var newList []*Activity
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// TakeWhileActivityErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type Activity and returns ([]Activity, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileActivityErr(f func(Activity) (bool, error), list []Activity) ([]Activity, error) {
	if f == nil {
		return []Activity{}, nil
	}
	var newList []Activity
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// PMapActivity applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapActivity(f func(Activity) Activity, list []Activity, optional ...fp.Optional) []Activity {
	if f == nil {
		return []Activity{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapActivityNoOrder(f, list, worker)
		}
	}

	return pMapActivityPreserveOrder(f, list, worker)
}

func pMapActivityPreserveOrder(f func(Activity) Activity, list []Activity, worker int) []Activity {
	chJobs := make(chan map[int]Activity, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]Activity{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]Activity, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]Activity, chJobs chan map[int]Activity) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]Activity{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]Activity, len(list))
	newList := make([]Activity, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapActivityNoOrder(f func(Activity) Activity, list []Activity, worker int) []Activity {
	chJobs := make(chan Activity, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan Activity, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan Activity, chJobs chan Activity) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]Activity, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapActivityPtr applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapActivityPtr(f func(*Activity) *Activity, list []*Activity, optional ...fp.Optional) []*Activity {
	if f == nil {
		return []*Activity{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapActivityPtrNoOrder(f, list, worker)
		}
	}

	return pMapActivityPtrPreserveOrder(f, list, worker)
}

func pMapActivityPtrPreserveOrder(f func(*Activity) *Activity, list []*Activity, worker int) []*Activity {
	chJobs := make(chan map[int]*Activity, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*Activity{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*Activity, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*Activity, chJobs chan map[int]*Activity) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]*Activity{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*Activity, len(list))
	newList := make([]*Activity, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapActivityPtrNoOrder(f func(*Activity) *Activity, list []*Activity, worker int) []*Activity {
	chJobs := make(chan *Activity, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *Activity, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *Activity, chJobs chan *Activity) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*Activity, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapActivityPtrErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapActivityPtrErr(f func(*Activity) (*Activity, error), list []*Activity, optional ...fp.Optional) ([]*Activity, error) {
	if f == nil {
		return []*Activity{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapActivityPtrErrNoOrder(f, list, worker)
		}
	}

	return pMapActivityPtrErrPreserveOrder(f, list, worker)
}

func pMapActivityPtrErrPreserveOrder(f func(*Activity) (*Activity, error), list []*Activity, worker int) ([]*Activity, error) {
	chJobs := make(chan map[int]*Activity, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*Activity{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*Activity, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*Activity, chJobs chan map[int]*Activity, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]*Activity{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*Activity, len(list))
	newList := make([]*Activity, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []*Activity{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []*Activity{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapActivityPtrErrNoOrder(f func(*Activity) (*Activity, error), list []*Activity, worker int) ([]*Activity, error) {
	chJobs := make(chan *Activity, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *Activity, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *Activity, chJobs chan *Activity, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*Activity, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []*Activity{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []*Activity{}, <-errCh
	}

	return newList, nil
}

// PMapActivityErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapActivityErr(f func(Activity) (Activity, error), list []Activity, optional ...fp.Optional) ([]Activity, error) {
	if f == nil {
		return []Activity{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapActivityErrNoOrder(f, list, worker)
		}
	}

	return pMapActivityErrPreserveOrder(f, list, worker)
}

func pMapActivityErrPreserveOrder(f func(Activity) (Activity, error), list []Activity, worker int) ([]Activity, error) {
	chJobs := make(chan map[int]Activity, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]Activity{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]Activity, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]Activity, chJobs chan map[int]Activity, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]Activity{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]Activity, len(list))
	newList := make([]Activity, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []Activity{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []Activity{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapActivityErrNoOrder(f func(Activity) (Activity, error), list []Activity, worker int) ([]Activity, error) {
	chJobs := make(chan Activity, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan Activity, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan Activity, chJobs chan Activity, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]Activity, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []Activity{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []Activity{}, <-errCh
	}

	return newList, nil
}

func FilterMapActivity(fFilter func(Activity) bool, fMap func(Activity) Activity, list []Activity) []Activity {
	if fFilter == nil || fMap == nil {
		return []Activity{}
	}
	var newList []Activity
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

func FilterMapActivityPtr(fFilter func(*Activity) bool, fMap func(*Activity) *Activity, list []*Activity) []*Activity {
	if fFilter == nil || fMap == nil {
		return []*Activity{}
	}
	var newList []*Activity
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapActivityPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(*Activity) and returns (bool, error).
//	2. Function: takes *Activity as argument and returns (*Activity, error)
// 	3. Slice of type []*Activity
//
// Returns:
//	New List ([]*Activity, error).
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapActivityPtrErr(fFilter func(*Activity) (bool, error), fMap func(*Activity) (*Activity, error), list []*Activity) ([]*Activity, error) {
	if fFilter == nil || fMap == nil {
		return []*Activity{}, nil
	}
	var newList []*Activity
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapActivityErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(Activity) and returns (bool, error).
//	2. Function: takes Activity as argument and returns (Activity, error)
// 	3. Slice of type []Activity
//
// Returns:
//	New List ([]Activity, error).
//  Empty list if all there parameters are nil or either of parameter is nil
//
func FilterMapActivityErr(fFilter func(Activity) (bool, error), fMap func(Activity) (Activity, error), list []Activity) ([]Activity, error) {
	if fFilter == nil || fMap == nil {
		return []Activity{}, nil
	}
	var newList []Activity
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

func RestActivity(l []Activity) []Activity {
	if l == nil {
		return []Activity{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []Activity{}
	}

	newList := make([]Activity, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}


// RestActivity removes 1st item of the list and return new list having rest of the items
func RestActivityPtr(l []*Activity) []*Activity {
	if l == nil {
		return []*Activity{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []*Activity{}
	}

	newList := make([]*Activity, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}

func ReduceActivity(f func(Activity, Activity) Activity, list []Activity, initializer ...Activity) Activity {
	var init Activity 
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}
	
	if lenList == 0 {
		return init
	}
	r := f(init, list[0])
	return ReduceActivity(f, list[1:], r)
}

func ReduceActivityPtr(f func(*Activity, *Activity) *Activity, list []*Activity, initializer ...Activity) *Activity {
	var initVal Activity
	var init *Activity = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init
	}

	r := f(init, list[0])
	return ReduceActivityPtr(f, list[1:], *r)
}

// ReduceActivityPtrErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (*Activity, *Activity)
//	B. list of type []*Activity
// 	C. initializer (optional of type Activity)
//
// Returns:
//	single value, error: (*Activity, error)
func ReduceActivityPtrErr(f func(*Activity, *Activity) (*Activity, error), list []*Activity, initializer ...Activity) (*Activity, error) {
	var initVal Activity
	var init *Activity = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return nil, err
	}
	return ReduceActivityPtrErr(f, list[1:], *r)
}

// ReduceActivityErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (Activity, Activity)
//	B. list of type []Activity
// 	C. initializer (optional of type Activity)
//
// Returns:
//	single value, error: (Activity, error)
func ReduceActivityErr(f func(Activity, Activity) (Activity, error), list []Activity, initializer ...Activity) (Activity, error) {
	var initVal Activity
	var init Activity = initVal
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return r, err
	}
	return ReduceActivityErr(f, list[1:], r)
}

// DropLastActivity drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastActivity(list []Activity) []Activity {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []Activity{}
	}

	newList := make([]Activity, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// DropLastActivityPtr drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastActivityPtr(list []*Activity) []*Activity {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []*Activity{}
	}

	newList := make([]*Activity, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// ReverseActivitys reverse the list
func ReverseActivitys(list []Activity) []Activity {
	newList := make([]Activity, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// ReverseActivitysPtr reverse the list
func ReverseActivitysPtr(list []*Activity) []*Activity {
	newList := make([]*Activity, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// TakeActivity returns n items in the list
func TakeActivity(n int, list []Activity) []Activity {
	if n < 0 {
		return []Activity{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]Activity, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

// TakeActivityPtr returns n items in the list
func TakeActivityPtr(n int, list []*Activity) []*Activity {
	if n < 0 {
		return []*Activity{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]*Activity, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

// DistinctActivityP returns true if no two of the arguments are =
func DistinctActivityP(list []Activity) bool {
	if len(list) == 0 {
		return false
	}

	for i := 0; i < len(list); i++ {
		for j := i + 1; j < len(list); j++ {
			if reflect.DeepEqual(list[i], list[j]) {
				return false
			}
		}
	}
	return true
}

// DistinctActivityPPtr returns true if no two of the arguments are =
func DistinctActivityPPtr(list []*Activity) bool {
	if len(list) == 0 {
		return false
	}

	for i := 0; i < len(list); i++ {
		for j := i + 1; j < len(list); j++ {
			if reflect.DeepEqual(*list[i], *list[j]) {
				return false
			}
		}
	}
	return true
}

// DistinctActivity removes duplicates.
func DistinctActivity(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}

	newList := []Activity{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(list[i], newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}

func DistinctActivityPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}

	newList := []*Activity{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(*list[i], *newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}

// UnionActivity return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivity(arrList ...[]Activity) []Activity {
	var newList []Activity

	for _, arr := range arrList {
		for _, v := range arr {
			found := false
			for i := 0; i < len(newList); i++ {
				if reflect.DeepEqual(newList[i], v) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, v)
			}
		}
	}
	return newList
}

// UnionActivityPtr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityPtr(arrList ...[]*Activity) []*Activity {
	var newList []*Activity

	for _, arr := range arrList {
		for _, v := range arr {
			found := false
			for i := 0; i < len(newList); i++ {
				if reflect.DeepEqual(*newList[i], *v) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, v)
			}
		}
	}
	return newList
}

// IntersectionActivity return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivity(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	var newList []Activity

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(arrList[0][i], v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// IntersectionActivityPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	var newList []*Activity

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(*arrList[0][i], *v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// DifferenceActivity returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivity(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	var newList []Activity

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(arrList[0][i], v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// DifferenceActivityPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	var newList []*Activity

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(*arrList[0][i], *v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// SubsetActivity returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored, order does not matter
func SubsetActivity(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list1); i++ {
		found := false
		for j := 0; j < len(list2); j++ {
			if reflect.DeepEqual(list1[i], list2[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// SubsetActivityPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored, order does not matter
func SubsetActivityPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list1); i++ {
		found := false
		for j := 0; j < len(list2); j++ {
			if reflect.DeepEqual(*list1[i], *list2[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// SupersetActivity returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored, order does not matter
func SupersetActivity(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list2); i++ {
		found := false
		for j := 0; j < len(list1); j++ {
			if reflect.DeepEqual(list2[i], list1[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// SupersetActivityPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored, order does not matter
func SupersetActivityPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list2); i++ {
		found := false
		for j := 0; j < len(list1); j++ {
			if reflect.DeepEqual(*list2[i], *list1[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// SetActivity returns a set of the distinct elements of coll.
func SetActivity(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}

	newList := []Activity{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(list[i], newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityPtr returns a set of the distinct elements of coll.
func SetActivityPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}

	newList := []*Activity{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(*list[i], *newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}



type byIDActivity []Activity

func (a byIDActivity) Len() int           { return len(a) }
func (a byIDActivity) Less(i, j int) bool { return a[i].ID < a[j].ID }
func (a byIDActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByID sort structs
func SortActivityByID(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byIDActivity(newList))
	return newList
}

// SortActivityByIDPtr sorts structs
func SortActivityByIDPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byIDActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byIDActivityDesc []Activity

func (a byIDActivityDesc) Len() int           { return len(a) }
func (a byIDActivityDesc) Less(i, j int) bool { return a[i].ID > a[j].ID }
func (a byIDActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByIDDesc sorts structs
func SortActivityByIDDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byIDActivityDesc(newList))
	return newList
}

// SortActivityByIDDescPtr sorts structs
func SortActivityByIDDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byIDActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byResourceStateActivity []Activity

func (a byResourceStateActivity) Len() int           { return len(a) }
func (a byResourceStateActivity) Less(i, j int) bool { return a[i].ResourceState < a[j].ResourceState }
func (a byResourceStateActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByResourceState sort structs
func SortActivityByResourceState(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byResourceStateActivity(newList))
	return newList
}

// SortActivityByResourceStatePtr sorts structs
func SortActivityByResourceStatePtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byResourceStateActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byResourceStateActivityDesc []Activity

func (a byResourceStateActivityDesc) Len() int           { return len(a) }
func (a byResourceStateActivityDesc) Less(i, j int) bool { return a[i].ResourceState > a[j].ResourceState }
func (a byResourceStateActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByResourceStateDesc sorts structs
func SortActivityByResourceStateDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byResourceStateActivityDesc(newList))
	return newList
}

// SortActivityByResourceStateDescPtr sorts structs
func SortActivityByResourceStateDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byResourceStateActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byExternalIDActivity []Activity

func (a byExternalIDActivity) Len() int           { return len(a) }
func (a byExternalIDActivity) Less(i, j int) bool { return a[i].ExternalID < a[j].ExternalID }
func (a byExternalIDActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByExternalID sort structs
func SortActivityByExternalID(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byExternalIDActivity(newList))
	return newList
}

// SortActivityByExternalIDPtr sorts structs
func SortActivityByExternalIDPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byExternalIDActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byExternalIDActivityDesc []Activity

func (a byExternalIDActivityDesc) Len() int           { return len(a) }
func (a byExternalIDActivityDesc) Less(i, j int) bool { return a[i].ExternalID > a[j].ExternalID }
func (a byExternalIDActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByExternalIDDesc sorts structs
func SortActivityByExternalIDDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byExternalIDActivityDesc(newList))
	return newList
}

// SortActivityByExternalIDDescPtr sorts structs
func SortActivityByExternalIDDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byExternalIDActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byUploadIDActivity []Activity

func (a byUploadIDActivity) Len() int           { return len(a) }
func (a byUploadIDActivity) Less(i, j int) bool { return a[i].UploadID < a[j].UploadID }
func (a byUploadIDActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByUploadID sort structs
func SortActivityByUploadID(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byUploadIDActivity(newList))
	return newList
}

// SortActivityByUploadIDPtr sorts structs
func SortActivityByUploadIDPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byUploadIDActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byUploadIDActivityDesc []Activity

func (a byUploadIDActivityDesc) Len() int           { return len(a) }
func (a byUploadIDActivityDesc) Less(i, j int) bool { return a[i].UploadID > a[j].UploadID }
func (a byUploadIDActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByUploadIDDesc sorts structs
func SortActivityByUploadIDDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byUploadIDActivityDesc(newList))
	return newList
}

// SortActivityByUploadIDDescPtr sorts structs
func SortActivityByUploadIDDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byUploadIDActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byNameActivity []Activity

func (a byNameActivity) Len() int           { return len(a) }
func (a byNameActivity) Less(i, j int) bool { return a[i].Name < a[j].Name }
func (a byNameActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByName sort structs
func SortActivityByName(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byNameActivity(newList))
	return newList
}

// SortActivityByNamePtr sorts structs
func SortActivityByNamePtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byNameActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byNameActivityDesc []Activity

func (a byNameActivityDesc) Len() int           { return len(a) }
func (a byNameActivityDesc) Less(i, j int) bool { return a[i].Name > a[j].Name }
func (a byNameActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByNameDesc sorts structs
func SortActivityByNameDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byNameActivityDesc(newList))
	return newList
}

// SortActivityByNameDescPtr sorts structs
func SortActivityByNameDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byNameActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byDistanceActivity []Activity

func (a byDistanceActivity) Len() int           { return len(a) }
func (a byDistanceActivity) Less(i, j int) bool { return a[i].Distance < a[j].Distance }
func (a byDistanceActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByDistance sort structs
func SortActivityByDistance(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byDistanceActivity(newList))
	return newList
}

// SortActivityByDistancePtr sorts structs
func SortActivityByDistancePtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byDistanceActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byDistanceActivityDesc []Activity

func (a byDistanceActivityDesc) Len() int           { return len(a) }
func (a byDistanceActivityDesc) Less(i, j int) bool { return a[i].Distance > a[j].Distance }
func (a byDistanceActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByDistanceDesc sorts structs
func SortActivityByDistanceDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byDistanceActivityDesc(newList))
	return newList
}

// SortActivityByDistanceDescPtr sorts structs
func SortActivityByDistanceDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byDistanceActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byMovingTimeActivity []Activity

func (a byMovingTimeActivity) Len() int           { return len(a) }
func (a byMovingTimeActivity) Less(i, j int) bool { return a[i].MovingTime < a[j].MovingTime }
func (a byMovingTimeActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByMovingTime sort structs
func SortActivityByMovingTime(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byMovingTimeActivity(newList))
	return newList
}

// SortActivityByMovingTimePtr sorts structs
func SortActivityByMovingTimePtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byMovingTimeActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byMovingTimeActivityDesc []Activity

func (a byMovingTimeActivityDesc) Len() int           { return len(a) }
func (a byMovingTimeActivityDesc) Less(i, j int) bool { return a[i].MovingTime > a[j].MovingTime }
func (a byMovingTimeActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByMovingTimeDesc sorts structs
func SortActivityByMovingTimeDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byMovingTimeActivityDesc(newList))
	return newList
}

// SortActivityByMovingTimeDescPtr sorts structs
func SortActivityByMovingTimeDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byMovingTimeActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byElapsedTimeActivity []Activity

func (a byElapsedTimeActivity) Len() int           { return len(a) }
func (a byElapsedTimeActivity) Less(i, j int) bool { return a[i].ElapsedTime < a[j].ElapsedTime }
func (a byElapsedTimeActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByElapsedTime sort structs
func SortActivityByElapsedTime(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byElapsedTimeActivity(newList))
	return newList
}

// SortActivityByElapsedTimePtr sorts structs
func SortActivityByElapsedTimePtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byElapsedTimeActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byElapsedTimeActivityDesc []Activity

func (a byElapsedTimeActivityDesc) Len() int           { return len(a) }
func (a byElapsedTimeActivityDesc) Less(i, j int) bool { return a[i].ElapsedTime > a[j].ElapsedTime }
func (a byElapsedTimeActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByElapsedTimeDesc sorts structs
func SortActivityByElapsedTimeDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byElapsedTimeActivityDesc(newList))
	return newList
}

// SortActivityByElapsedTimeDescPtr sorts structs
func SortActivityByElapsedTimeDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byElapsedTimeActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byTotalElevationGainActivity []Activity

func (a byTotalElevationGainActivity) Len() int           { return len(a) }
func (a byTotalElevationGainActivity) Less(i, j int) bool { return a[i].TotalElevationGain < a[j].TotalElevationGain }
func (a byTotalElevationGainActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByTotalElevationGain sort structs
func SortActivityByTotalElevationGain(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byTotalElevationGainActivity(newList))
	return newList
}

// SortActivityByTotalElevationGainPtr sorts structs
func SortActivityByTotalElevationGainPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byTotalElevationGainActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byTotalElevationGainActivityDesc []Activity

func (a byTotalElevationGainActivityDesc) Len() int           { return len(a) }
func (a byTotalElevationGainActivityDesc) Less(i, j int) bool { return a[i].TotalElevationGain > a[j].TotalElevationGain }
func (a byTotalElevationGainActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByTotalElevationGainDesc sorts structs
func SortActivityByTotalElevationGainDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byTotalElevationGainActivityDesc(newList))
	return newList
}

// SortActivityByTotalElevationGainDescPtr sorts structs
func SortActivityByTotalElevationGainDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byTotalElevationGainActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byTypeActivity []Activity

func (a byTypeActivity) Len() int           { return len(a) }
func (a byTypeActivity) Less(i, j int) bool { return a[i].Type < a[j].Type }
func (a byTypeActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByType sort structs
func SortActivityByType(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byTypeActivity(newList))
	return newList
}

// SortActivityByTypePtr sorts structs
func SortActivityByTypePtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byTypeActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byTypeActivityDesc []Activity

func (a byTypeActivityDesc) Len() int           { return len(a) }
func (a byTypeActivityDesc) Less(i, j int) bool { return a[i].Type > a[j].Type }
func (a byTypeActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByTypeDesc sorts structs
func SortActivityByTypeDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byTypeActivityDesc(newList))
	return newList
}

// SortActivityByTypeDescPtr sorts structs
func SortActivityByTypeDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byTypeActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byStartDateActivity []Activity

func (a byStartDateActivity) Len() int           { return len(a) }
func (a byStartDateActivity) Less(i, j int) bool { return a[i].StartDate.Before(a[j].StartDate) }
func (a byStartDateActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByStartDate sort structs
func SortActivityByStartDate(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byStartDateActivity(newList))
	return newList
}

// SortActivityByStartDatePtr sorts structs
func SortActivityByStartDatePtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byStartDateActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byStartDateActivityDesc []Activity

func (a byStartDateActivityDesc) Len() int           { return len(a) }
func (a byStartDateActivityDesc) Less(i, j int) bool { return a[i].StartDate.After(a[j].StartDate) }
func (a byStartDateActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByStartDateDesc sorts structs
func SortActivityByStartDateDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byStartDateActivityDesc(newList))
	return newList
}

// SortActivityByStartDateDescPtr sorts structs
func SortActivityByStartDateDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byStartDateActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byStartDateLocalActivity []Activity

func (a byStartDateLocalActivity) Len() int           { return len(a) }
func (a byStartDateLocalActivity) Less(i, j int) bool { return a[i].StartDateLocal.Before(a[j].StartDateLocal) }
func (a byStartDateLocalActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByStartDateLocal sort structs
func SortActivityByStartDateLocal(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byStartDateLocalActivity(newList))
	return newList
}

// SortActivityByStartDateLocalPtr sorts structs
func SortActivityByStartDateLocalPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byStartDateLocalActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byStartDateLocalActivityDesc []Activity

func (a byStartDateLocalActivityDesc) Len() int           { return len(a) }
func (a byStartDateLocalActivityDesc) Less(i, j int) bool { return a[i].StartDateLocal.After(a[j].StartDateLocal) }
func (a byStartDateLocalActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByStartDateLocalDesc sorts structs
func SortActivityByStartDateLocalDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byStartDateLocalActivityDesc(newList))
	return newList
}

// SortActivityByStartDateLocalDescPtr sorts structs
func SortActivityByStartDateLocalDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byStartDateLocalActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byTimezoneActivity []Activity

func (a byTimezoneActivity) Len() int           { return len(a) }
func (a byTimezoneActivity) Less(i, j int) bool { return a[i].Timezone < a[j].Timezone }
func (a byTimezoneActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByTimezone sort structs
func SortActivityByTimezone(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byTimezoneActivity(newList))
	return newList
}

// SortActivityByTimezonePtr sorts structs
func SortActivityByTimezonePtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byTimezoneActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byTimezoneActivityDesc []Activity

func (a byTimezoneActivityDesc) Len() int           { return len(a) }
func (a byTimezoneActivityDesc) Less(i, j int) bool { return a[i].Timezone > a[j].Timezone }
func (a byTimezoneActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByTimezoneDesc sorts structs
func SortActivityByTimezoneDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byTimezoneActivityDesc(newList))
	return newList
}

// SortActivityByTimezoneDescPtr sorts structs
func SortActivityByTimezoneDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byTimezoneActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byUtcOffsetActivity []Activity

func (a byUtcOffsetActivity) Len() int           { return len(a) }
func (a byUtcOffsetActivity) Less(i, j int) bool { return a[i].UtcOffset < a[j].UtcOffset }
func (a byUtcOffsetActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByUtcOffset sort structs
func SortActivityByUtcOffset(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byUtcOffsetActivity(newList))
	return newList
}

// SortActivityByUtcOffsetPtr sorts structs
func SortActivityByUtcOffsetPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byUtcOffsetActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byUtcOffsetActivityDesc []Activity

func (a byUtcOffsetActivityDesc) Len() int           { return len(a) }
func (a byUtcOffsetActivityDesc) Less(i, j int) bool { return a[i].UtcOffset > a[j].UtcOffset }
func (a byUtcOffsetActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByUtcOffsetDesc sorts structs
func SortActivityByUtcOffsetDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byUtcOffsetActivityDesc(newList))
	return newList
}

// SortActivityByUtcOffsetDescPtr sorts structs
func SortActivityByUtcOffsetDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byUtcOffsetActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byLocationCityActivity []Activity

func (a byLocationCityActivity) Len() int           { return len(a) }
func (a byLocationCityActivity) Less(i, j int) bool { return a[i].LocationCity < a[j].LocationCity }
func (a byLocationCityActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByLocationCity sort structs
func SortActivityByLocationCity(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byLocationCityActivity(newList))
	return newList
}

// SortActivityByLocationCityPtr sorts structs
func SortActivityByLocationCityPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byLocationCityActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byLocationCityActivityDesc []Activity

func (a byLocationCityActivityDesc) Len() int           { return len(a) }
func (a byLocationCityActivityDesc) Less(i, j int) bool { return a[i].LocationCity > a[j].LocationCity }
func (a byLocationCityActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByLocationCityDesc sorts structs
func SortActivityByLocationCityDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byLocationCityActivityDesc(newList))
	return newList
}

// SortActivityByLocationCityDescPtr sorts structs
func SortActivityByLocationCityDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byLocationCityActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byLocationStateActivity []Activity

func (a byLocationStateActivity) Len() int           { return len(a) }
func (a byLocationStateActivity) Less(i, j int) bool { return a[i].LocationState < a[j].LocationState }
func (a byLocationStateActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByLocationState sort structs
func SortActivityByLocationState(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byLocationStateActivity(newList))
	return newList
}

// SortActivityByLocationStatePtr sorts structs
func SortActivityByLocationStatePtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byLocationStateActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byLocationStateActivityDesc []Activity

func (a byLocationStateActivityDesc) Len() int           { return len(a) }
func (a byLocationStateActivityDesc) Less(i, j int) bool { return a[i].LocationState > a[j].LocationState }
func (a byLocationStateActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByLocationStateDesc sorts structs
func SortActivityByLocationStateDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byLocationStateActivityDesc(newList))
	return newList
}

// SortActivityByLocationStateDescPtr sorts structs
func SortActivityByLocationStateDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byLocationStateActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byLocationCountryActivity []Activity

func (a byLocationCountryActivity) Len() int           { return len(a) }
func (a byLocationCountryActivity) Less(i, j int) bool { return a[i].LocationCountry < a[j].LocationCountry }
func (a byLocationCountryActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByLocationCountry sort structs
func SortActivityByLocationCountry(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byLocationCountryActivity(newList))
	return newList
}

// SortActivityByLocationCountryPtr sorts structs
func SortActivityByLocationCountryPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byLocationCountryActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byLocationCountryActivityDesc []Activity

func (a byLocationCountryActivityDesc) Len() int           { return len(a) }
func (a byLocationCountryActivityDesc) Less(i, j int) bool { return a[i].LocationCountry > a[j].LocationCountry }
func (a byLocationCountryActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByLocationCountryDesc sorts structs
func SortActivityByLocationCountryDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byLocationCountryActivityDesc(newList))
	return newList
}

// SortActivityByLocationCountryDescPtr sorts structs
func SortActivityByLocationCountryDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byLocationCountryActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byAchievementCountActivity []Activity

func (a byAchievementCountActivity) Len() int           { return len(a) }
func (a byAchievementCountActivity) Less(i, j int) bool { return a[i].AchievementCount < a[j].AchievementCount }
func (a byAchievementCountActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByAchievementCount sort structs
func SortActivityByAchievementCount(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byAchievementCountActivity(newList))
	return newList
}

// SortActivityByAchievementCountPtr sorts structs
func SortActivityByAchievementCountPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byAchievementCountActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byAchievementCountActivityDesc []Activity

func (a byAchievementCountActivityDesc) Len() int           { return len(a) }
func (a byAchievementCountActivityDesc) Less(i, j int) bool { return a[i].AchievementCount > a[j].AchievementCount }
func (a byAchievementCountActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByAchievementCountDesc sorts structs
func SortActivityByAchievementCountDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byAchievementCountActivityDesc(newList))
	return newList
}

// SortActivityByAchievementCountDescPtr sorts structs
func SortActivityByAchievementCountDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byAchievementCountActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byKudosCountActivity []Activity

func (a byKudosCountActivity) Len() int           { return len(a) }
func (a byKudosCountActivity) Less(i, j int) bool { return a[i].KudosCount < a[j].KudosCount }
func (a byKudosCountActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByKudosCount sort structs
func SortActivityByKudosCount(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byKudosCountActivity(newList))
	return newList
}

// SortActivityByKudosCountPtr sorts structs
func SortActivityByKudosCountPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byKudosCountActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byKudosCountActivityDesc []Activity

func (a byKudosCountActivityDesc) Len() int           { return len(a) }
func (a byKudosCountActivityDesc) Less(i, j int) bool { return a[i].KudosCount > a[j].KudosCount }
func (a byKudosCountActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByKudosCountDesc sorts structs
func SortActivityByKudosCountDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byKudosCountActivityDesc(newList))
	return newList
}

// SortActivityByKudosCountDescPtr sorts structs
func SortActivityByKudosCountDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byKudosCountActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byCommentCountActivity []Activity

func (a byCommentCountActivity) Len() int           { return len(a) }
func (a byCommentCountActivity) Less(i, j int) bool { return a[i].CommentCount < a[j].CommentCount }
func (a byCommentCountActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByCommentCount sort structs
func SortActivityByCommentCount(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byCommentCountActivity(newList))
	return newList
}

// SortActivityByCommentCountPtr sorts structs
func SortActivityByCommentCountPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byCommentCountActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byCommentCountActivityDesc []Activity

func (a byCommentCountActivityDesc) Len() int           { return len(a) }
func (a byCommentCountActivityDesc) Less(i, j int) bool { return a[i].CommentCount > a[j].CommentCount }
func (a byCommentCountActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByCommentCountDesc sorts structs
func SortActivityByCommentCountDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byCommentCountActivityDesc(newList))
	return newList
}

// SortActivityByCommentCountDescPtr sorts structs
func SortActivityByCommentCountDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byCommentCountActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byAthleteCountActivity []Activity

func (a byAthleteCountActivity) Len() int           { return len(a) }
func (a byAthleteCountActivity) Less(i, j int) bool { return a[i].AthleteCount < a[j].AthleteCount }
func (a byAthleteCountActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByAthleteCount sort structs
func SortActivityByAthleteCount(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byAthleteCountActivity(newList))
	return newList
}

// SortActivityByAthleteCountPtr sorts structs
func SortActivityByAthleteCountPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byAthleteCountActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byAthleteCountActivityDesc []Activity

func (a byAthleteCountActivityDesc) Len() int           { return len(a) }
func (a byAthleteCountActivityDesc) Less(i, j int) bool { return a[i].AthleteCount > a[j].AthleteCount }
func (a byAthleteCountActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByAthleteCountDesc sorts structs
func SortActivityByAthleteCountDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byAthleteCountActivityDesc(newList))
	return newList
}

// SortActivityByAthleteCountDescPtr sorts structs
func SortActivityByAthleteCountDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byAthleteCountActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byPhotoCountActivity []Activity

func (a byPhotoCountActivity) Len() int           { return len(a) }
func (a byPhotoCountActivity) Less(i, j int) bool { return a[i].PhotoCount < a[j].PhotoCount }
func (a byPhotoCountActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByPhotoCount sort structs
func SortActivityByPhotoCount(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byPhotoCountActivity(newList))
	return newList
}

// SortActivityByPhotoCountPtr sorts structs
func SortActivityByPhotoCountPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byPhotoCountActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byPhotoCountActivityDesc []Activity

func (a byPhotoCountActivityDesc) Len() int           { return len(a) }
func (a byPhotoCountActivityDesc) Less(i, j int) bool { return a[i].PhotoCount > a[j].PhotoCount }
func (a byPhotoCountActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByPhotoCountDesc sorts structs
func SortActivityByPhotoCountDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byPhotoCountActivityDesc(newList))
	return newList
}

// SortActivityByPhotoCountDescPtr sorts structs
func SortActivityByPhotoCountDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byPhotoCountActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byGearIDActivity []Activity

func (a byGearIDActivity) Len() int           { return len(a) }
func (a byGearIDActivity) Less(i, j int) bool { return a[i].GearID < a[j].GearID }
func (a byGearIDActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByGearID sort structs
func SortActivityByGearID(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byGearIDActivity(newList))
	return newList
}

// SortActivityByGearIDPtr sorts structs
func SortActivityByGearIDPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byGearIDActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byGearIDActivityDesc []Activity

func (a byGearIDActivityDesc) Len() int           { return len(a) }
func (a byGearIDActivityDesc) Less(i, j int) bool { return a[i].GearID > a[j].GearID }
func (a byGearIDActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByGearIDDesc sorts structs
func SortActivityByGearIDDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byGearIDActivityDesc(newList))
	return newList
}

// SortActivityByGearIDDescPtr sorts structs
func SortActivityByGearIDDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byGearIDActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byAverageSpeedActivity []Activity

func (a byAverageSpeedActivity) Len() int           { return len(a) }
func (a byAverageSpeedActivity) Less(i, j int) bool { return a[i].AverageSpeed < a[j].AverageSpeed }
func (a byAverageSpeedActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByAverageSpeed sort structs
func SortActivityByAverageSpeed(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byAverageSpeedActivity(newList))
	return newList
}

// SortActivityByAverageSpeedPtr sorts structs
func SortActivityByAverageSpeedPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byAverageSpeedActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byAverageSpeedActivityDesc []Activity

func (a byAverageSpeedActivityDesc) Len() int           { return len(a) }
func (a byAverageSpeedActivityDesc) Less(i, j int) bool { return a[i].AverageSpeed > a[j].AverageSpeed }
func (a byAverageSpeedActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByAverageSpeedDesc sorts structs
func SortActivityByAverageSpeedDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byAverageSpeedActivityDesc(newList))
	return newList
}

// SortActivityByAverageSpeedDescPtr sorts structs
func SortActivityByAverageSpeedDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byAverageSpeedActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byMaxSpeedActivity []Activity

func (a byMaxSpeedActivity) Len() int           { return len(a) }
func (a byMaxSpeedActivity) Less(i, j int) bool { return a[i].MaxSpeed < a[j].MaxSpeed }
func (a byMaxSpeedActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByMaxSpeed sort structs
func SortActivityByMaxSpeed(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byMaxSpeedActivity(newList))
	return newList
}

// SortActivityByMaxSpeedPtr sorts structs
func SortActivityByMaxSpeedPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byMaxSpeedActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byMaxSpeedActivityDesc []Activity

func (a byMaxSpeedActivityDesc) Len() int           { return len(a) }
func (a byMaxSpeedActivityDesc) Less(i, j int) bool { return a[i].MaxSpeed > a[j].MaxSpeed }
func (a byMaxSpeedActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByMaxSpeedDesc sorts structs
func SortActivityByMaxSpeedDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byMaxSpeedActivityDesc(newList))
	return newList
}

// SortActivityByMaxSpeedDescPtr sorts structs
func SortActivityByMaxSpeedDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byMaxSpeedActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byAverageCadenceActivity []Activity

func (a byAverageCadenceActivity) Len() int           { return len(a) }
func (a byAverageCadenceActivity) Less(i, j int) bool { return a[i].AverageCadence < a[j].AverageCadence }
func (a byAverageCadenceActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByAverageCadence sort structs
func SortActivityByAverageCadence(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byAverageCadenceActivity(newList))
	return newList
}

// SortActivityByAverageCadencePtr sorts structs
func SortActivityByAverageCadencePtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byAverageCadenceActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byAverageCadenceActivityDesc []Activity

func (a byAverageCadenceActivityDesc) Len() int           { return len(a) }
func (a byAverageCadenceActivityDesc) Less(i, j int) bool { return a[i].AverageCadence > a[j].AverageCadence }
func (a byAverageCadenceActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByAverageCadenceDesc sorts structs
func SortActivityByAverageCadenceDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byAverageCadenceActivityDesc(newList))
	return newList
}

// SortActivityByAverageCadenceDescPtr sorts structs
func SortActivityByAverageCadenceDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byAverageCadenceActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byAverageTempActivity []Activity

func (a byAverageTempActivity) Len() int           { return len(a) }
func (a byAverageTempActivity) Less(i, j int) bool { return a[i].AverageTemp < a[j].AverageTemp }
func (a byAverageTempActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByAverageTemp sort structs
func SortActivityByAverageTemp(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byAverageTempActivity(newList))
	return newList
}

// SortActivityByAverageTempPtr sorts structs
func SortActivityByAverageTempPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byAverageTempActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byAverageTempActivityDesc []Activity

func (a byAverageTempActivityDesc) Len() int           { return len(a) }
func (a byAverageTempActivityDesc) Less(i, j int) bool { return a[i].AverageTemp > a[j].AverageTemp }
func (a byAverageTempActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByAverageTempDesc sorts structs
func SortActivityByAverageTempDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byAverageTempActivityDesc(newList))
	return newList
}

// SortActivityByAverageTempDescPtr sorts structs
func SortActivityByAverageTempDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byAverageTempActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byAverageWattsActivity []Activity

func (a byAverageWattsActivity) Len() int           { return len(a) }
func (a byAverageWattsActivity) Less(i, j int) bool { return a[i].AverageWatts < a[j].AverageWatts }
func (a byAverageWattsActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByAverageWatts sort structs
func SortActivityByAverageWatts(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byAverageWattsActivity(newList))
	return newList
}

// SortActivityByAverageWattsPtr sorts structs
func SortActivityByAverageWattsPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byAverageWattsActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byAverageWattsActivityDesc []Activity

func (a byAverageWattsActivityDesc) Len() int           { return len(a) }
func (a byAverageWattsActivityDesc) Less(i, j int) bool { return a[i].AverageWatts > a[j].AverageWatts }
func (a byAverageWattsActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByAverageWattsDesc sorts structs
func SortActivityByAverageWattsDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byAverageWattsActivityDesc(newList))
	return newList
}

// SortActivityByAverageWattsDescPtr sorts structs
func SortActivityByAverageWattsDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byAverageWattsActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byWeightedAverageWattsActivity []Activity

func (a byWeightedAverageWattsActivity) Len() int           { return len(a) }
func (a byWeightedAverageWattsActivity) Less(i, j int) bool { return a[i].WeightedAverageWatts < a[j].WeightedAverageWatts }
func (a byWeightedAverageWattsActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByWeightedAverageWatts sort structs
func SortActivityByWeightedAverageWatts(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byWeightedAverageWattsActivity(newList))
	return newList
}

// SortActivityByWeightedAverageWattsPtr sorts structs
func SortActivityByWeightedAverageWattsPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byWeightedAverageWattsActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byWeightedAverageWattsActivityDesc []Activity

func (a byWeightedAverageWattsActivityDesc) Len() int           { return len(a) }
func (a byWeightedAverageWattsActivityDesc) Less(i, j int) bool { return a[i].WeightedAverageWatts > a[j].WeightedAverageWatts }
func (a byWeightedAverageWattsActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByWeightedAverageWattsDesc sorts structs
func SortActivityByWeightedAverageWattsDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byWeightedAverageWattsActivityDesc(newList))
	return newList
}

// SortActivityByWeightedAverageWattsDescPtr sorts structs
func SortActivityByWeightedAverageWattsDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byWeightedAverageWattsActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byKilojoulesActivity []Activity

func (a byKilojoulesActivity) Len() int           { return len(a) }
func (a byKilojoulesActivity) Less(i, j int) bool { return a[i].Kilojoules < a[j].Kilojoules }
func (a byKilojoulesActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByKilojoules sort structs
func SortActivityByKilojoules(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byKilojoulesActivity(newList))
	return newList
}

// SortActivityByKilojoulesPtr sorts structs
func SortActivityByKilojoulesPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byKilojoulesActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byKilojoulesActivityDesc []Activity

func (a byKilojoulesActivityDesc) Len() int           { return len(a) }
func (a byKilojoulesActivityDesc) Less(i, j int) bool { return a[i].Kilojoules > a[j].Kilojoules }
func (a byKilojoulesActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByKilojoulesDesc sorts structs
func SortActivityByKilojoulesDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byKilojoulesActivityDesc(newList))
	return newList
}

// SortActivityByKilojoulesDescPtr sorts structs
func SortActivityByKilojoulesDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byKilojoulesActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byMaxWattsActivity []Activity

func (a byMaxWattsActivity) Len() int           { return len(a) }
func (a byMaxWattsActivity) Less(i, j int) bool { return a[i].MaxWatts < a[j].MaxWatts }
func (a byMaxWattsActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByMaxWatts sort structs
func SortActivityByMaxWatts(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byMaxWattsActivity(newList))
	return newList
}

// SortActivityByMaxWattsPtr sorts structs
func SortActivityByMaxWattsPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byMaxWattsActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byMaxWattsActivityDesc []Activity

func (a byMaxWattsActivityDesc) Len() int           { return len(a) }
func (a byMaxWattsActivityDesc) Less(i, j int) bool { return a[i].MaxWatts > a[j].MaxWatts }
func (a byMaxWattsActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByMaxWattsDesc sorts structs
func SortActivityByMaxWattsDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byMaxWattsActivityDesc(newList))
	return newList
}

// SortActivityByMaxWattsDescPtr sorts structs
func SortActivityByMaxWattsDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byMaxWattsActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byElevationHighActivity []Activity

func (a byElevationHighActivity) Len() int           { return len(a) }
func (a byElevationHighActivity) Less(i, j int) bool { return a[i].ElevationHigh < a[j].ElevationHigh }
func (a byElevationHighActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByElevationHigh sort structs
func SortActivityByElevationHigh(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byElevationHighActivity(newList))
	return newList
}

// SortActivityByElevationHighPtr sorts structs
func SortActivityByElevationHighPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byElevationHighActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byElevationHighActivityDesc []Activity

func (a byElevationHighActivityDesc) Len() int           { return len(a) }
func (a byElevationHighActivityDesc) Less(i, j int) bool { return a[i].ElevationHigh > a[j].ElevationHigh }
func (a byElevationHighActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByElevationHighDesc sorts structs
func SortActivityByElevationHighDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byElevationHighActivityDesc(newList))
	return newList
}

// SortActivityByElevationHighDescPtr sorts structs
func SortActivityByElevationHighDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byElevationHighActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byElevationLowActivity []Activity

func (a byElevationLowActivity) Len() int           { return len(a) }
func (a byElevationLowActivity) Less(i, j int) bool { return a[i].ElevationLow < a[j].ElevationLow }
func (a byElevationLowActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByElevationLow sort structs
func SortActivityByElevationLow(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byElevationLowActivity(newList))
	return newList
}

// SortActivityByElevationLowPtr sorts structs
func SortActivityByElevationLowPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byElevationLowActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byElevationLowActivityDesc []Activity

func (a byElevationLowActivityDesc) Len() int           { return len(a) }
func (a byElevationLowActivityDesc) Less(i, j int) bool { return a[i].ElevationLow > a[j].ElevationLow }
func (a byElevationLowActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByElevationLowDesc sorts structs
func SortActivityByElevationLowDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byElevationLowActivityDesc(newList))
	return newList
}

// SortActivityByElevationLowDescPtr sorts structs
func SortActivityByElevationLowDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byElevationLowActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byPrCountActivity []Activity

func (a byPrCountActivity) Len() int           { return len(a) }
func (a byPrCountActivity) Less(i, j int) bool { return a[i].PrCount < a[j].PrCount }
func (a byPrCountActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByPrCount sort structs
func SortActivityByPrCount(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byPrCountActivity(newList))
	return newList
}

// SortActivityByPrCountPtr sorts structs
func SortActivityByPrCountPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byPrCountActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byPrCountActivityDesc []Activity

func (a byPrCountActivityDesc) Len() int           { return len(a) }
func (a byPrCountActivityDesc) Less(i, j int) bool { return a[i].PrCount > a[j].PrCount }
func (a byPrCountActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByPrCountDesc sorts structs
func SortActivityByPrCountDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byPrCountActivityDesc(newList))
	return newList
}

// SortActivityByPrCountDescPtr sorts structs
func SortActivityByPrCountDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byPrCountActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byTotalPhotoCountActivity []Activity

func (a byTotalPhotoCountActivity) Len() int           { return len(a) }
func (a byTotalPhotoCountActivity) Less(i, j int) bool { return a[i].TotalPhotoCount < a[j].TotalPhotoCount }
func (a byTotalPhotoCountActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByTotalPhotoCount sort structs
func SortActivityByTotalPhotoCount(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byTotalPhotoCountActivity(newList))
	return newList
}

// SortActivityByTotalPhotoCountPtr sorts structs
func SortActivityByTotalPhotoCountPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byTotalPhotoCountActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byTotalPhotoCountActivityDesc []Activity

func (a byTotalPhotoCountActivityDesc) Len() int           { return len(a) }
func (a byTotalPhotoCountActivityDesc) Less(i, j int) bool { return a[i].TotalPhotoCount > a[j].TotalPhotoCount }
func (a byTotalPhotoCountActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByTotalPhotoCountDesc sorts structs
func SortActivityByTotalPhotoCountDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byTotalPhotoCountActivityDesc(newList))
	return newList
}

// SortActivityByTotalPhotoCountDescPtr sorts structs
func SortActivityByTotalPhotoCountDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byTotalPhotoCountActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byWorkoutTypeActivity []Activity

func (a byWorkoutTypeActivity) Len() int           { return len(a) }
func (a byWorkoutTypeActivity) Less(i, j int) bool { return a[i].WorkoutType < a[j].WorkoutType }
func (a byWorkoutTypeActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByWorkoutType sort structs
func SortActivityByWorkoutType(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byWorkoutTypeActivity(newList))
	return newList
}

// SortActivityByWorkoutTypePtr sorts structs
func SortActivityByWorkoutTypePtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byWorkoutTypeActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byWorkoutTypeActivityDesc []Activity

func (a byWorkoutTypeActivityDesc) Len() int           { return len(a) }
func (a byWorkoutTypeActivityDesc) Less(i, j int) bool { return a[i].WorkoutType > a[j].WorkoutType }
func (a byWorkoutTypeActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByWorkoutTypeDesc sorts structs
func SortActivityByWorkoutTypeDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byWorkoutTypeActivityDesc(newList))
	return newList
}

// SortActivityByWorkoutTypeDescPtr sorts structs
func SortActivityByWorkoutTypeDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byWorkoutTypeActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type bySufferScoreActivity []Activity

func (a bySufferScoreActivity) Len() int           { return len(a) }
func (a bySufferScoreActivity) Less(i, j int) bool { return a[i].SufferScore < a[j].SufferScore }
func (a bySufferScoreActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityBySufferScore sort structs
func SortActivityBySufferScore(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(bySufferScoreActivity(newList))
	return newList
}

// SortActivityBySufferScorePtr sorts structs
func SortActivityBySufferScorePtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(bySufferScoreActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type bySufferScoreActivityDesc []Activity

func (a bySufferScoreActivityDesc) Len() int           { return len(a) }
func (a bySufferScoreActivityDesc) Less(i, j int) bool { return a[i].SufferScore > a[j].SufferScore }
func (a bySufferScoreActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityBySufferScoreDesc sorts structs
func SortActivityBySufferScoreDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(bySufferScoreActivityDesc(newList))
	return newList
}

// SortActivityBySufferScoreDescPtr sorts structs
func SortActivityBySufferScoreDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(bySufferScoreActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byDescriptionActivity []Activity

func (a byDescriptionActivity) Len() int           { return len(a) }
func (a byDescriptionActivity) Less(i, j int) bool { return a[i].Description < a[j].Description }
func (a byDescriptionActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByDescription sort structs
func SortActivityByDescription(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byDescriptionActivity(newList))
	return newList
}

// SortActivityByDescriptionPtr sorts structs
func SortActivityByDescriptionPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byDescriptionActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byDescriptionActivityDesc []Activity

func (a byDescriptionActivityDesc) Len() int           { return len(a) }
func (a byDescriptionActivityDesc) Less(i, j int) bool { return a[i].Description > a[j].Description }
func (a byDescriptionActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByDescriptionDesc sorts structs
func SortActivityByDescriptionDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byDescriptionActivityDesc(newList))
	return newList
}

// SortActivityByDescriptionDescPtr sorts structs
func SortActivityByDescriptionDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byDescriptionActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byCaloriesActivity []Activity

func (a byCaloriesActivity) Len() int           { return len(a) }
func (a byCaloriesActivity) Less(i, j int) bool { return a[i].Calories < a[j].Calories }
func (a byCaloriesActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByCalories sort structs
func SortActivityByCalories(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byCaloriesActivity(newList))
	return newList
}

// SortActivityByCaloriesPtr sorts structs
func SortActivityByCaloriesPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byCaloriesActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byCaloriesActivityDesc []Activity

func (a byCaloriesActivityDesc) Len() int           { return len(a) }
func (a byCaloriesActivityDesc) Less(i, j int) bool { return a[i].Calories > a[j].Calories }
func (a byCaloriesActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByCaloriesDesc sorts structs
func SortActivityByCaloriesDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byCaloriesActivityDesc(newList))
	return newList
}

// SortActivityByCaloriesDescPtr sorts structs
func SortActivityByCaloriesDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byCaloriesActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byDeviceNameActivity []Activity

func (a byDeviceNameActivity) Len() int           { return len(a) }
func (a byDeviceNameActivity) Less(i, j int) bool { return a[i].DeviceName < a[j].DeviceName }
func (a byDeviceNameActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByDeviceName sort structs
func SortActivityByDeviceName(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byDeviceNameActivity(newList))
	return newList
}

// SortActivityByDeviceNamePtr sorts structs
func SortActivityByDeviceNamePtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byDeviceNameActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byDeviceNameActivityDesc []Activity

func (a byDeviceNameActivityDesc) Len() int           { return len(a) }
func (a byDeviceNameActivityDesc) Less(i, j int) bool { return a[i].DeviceName > a[j].DeviceName }
func (a byDeviceNameActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByDeviceNameDesc sorts structs
func SortActivityByDeviceNameDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byDeviceNameActivityDesc(newList))
	return newList
}

// SortActivityByDeviceNameDescPtr sorts structs
func SortActivityByDeviceNameDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byDeviceNameActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byEmbedTokenActivity []Activity

func (a byEmbedTokenActivity) Len() int           { return len(a) }
func (a byEmbedTokenActivity) Less(i, j int) bool { return a[i].EmbedToken < a[j].EmbedToken }
func (a byEmbedTokenActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByEmbedToken sort structs
func SortActivityByEmbedToken(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byEmbedTokenActivity(newList))
	return newList
}

// SortActivityByEmbedTokenPtr sorts structs
func SortActivityByEmbedTokenPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byEmbedTokenActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byEmbedTokenActivityDesc []Activity

func (a byEmbedTokenActivityDesc) Len() int           { return len(a) }
func (a byEmbedTokenActivityDesc) Less(i, j int) bool { return a[i].EmbedToken > a[j].EmbedToken }
func (a byEmbedTokenActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByEmbedTokenDesc sorts structs
func SortActivityByEmbedTokenDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byEmbedTokenActivityDesc(newList))
	return newList
}

// SortActivityByEmbedTokenDescPtr sorts structs
func SortActivityByEmbedTokenDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byEmbedTokenActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
type byPerceivedExertionActivity []Activity

func (a byPerceivedExertionActivity) Len() int           { return len(a) }
func (a byPerceivedExertionActivity) Less(i, j int) bool { return a[i].PerceivedExertion < a[j].PerceivedExertion }
func (a byPerceivedExertionActivity) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByPerceivedExertion sort structs
func SortActivityByPerceivedExertion(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byPerceivedExertionActivity(newList))
	return newList
}

// SortActivityByPerceivedExertionPtr sorts structs
func SortActivityByPerceivedExertionPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byPerceivedExertionActivity(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}

type byPerceivedExertionActivityDesc []Activity

func (a byPerceivedExertionActivityDesc) Len() int           { return len(a) }
func (a byPerceivedExertionActivityDesc) Less(i, j int) bool { return a[i].PerceivedExertion > a[j].PerceivedExertion }
func (a byPerceivedExertionActivityDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// SortActivityByPerceivedExertionDesc sorts structs
func SortActivityByPerceivedExertionDesc(list []Activity) []Activity {
	if len(list) == 0 {
		return []Activity{}
	}
	newList := make([]Activity, len(list))
	for i, item := range list {
		newList[i] = item
	}
	sort.Sort(byPerceivedExertionActivityDesc(newList))
	return newList
}

// SortActivityByPerceivedExertionDescPtr sorts structs
func SortActivityByPerceivedExertionDescPtr(list []*Activity) []*Activity {
	if len(list) == 0 {
		return []*Activity{}
	}
	newList := make([]Activity, len(list))
	newListPtr := make([]*Activity, len(list))

	for i, item := range list {
		newList[i] = *item
	}
	sort.Sort(byPerceivedExertionActivityDesc(newList))

	for i := 0; i < len(newList); i++ {
		newListPtr[i] = &newList[i]
	}
	return newListPtr
}
// UnionActivityByID return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByID(arrList ...[]Activity) []Activity {
	resultMap := make(map[int64]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.ID]
			if !ok {
				resultMap[v.ID] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByIDPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[int64]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.ID]
			if !ok {
				resultMap[v.ID] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByID return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByID(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ID] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ID == v.ID {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].ID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ID] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByIDPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByIDPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ID]
			if !ok {
				resultMap[arrList[0][i].ID] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ID == v.ID {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].ID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ID] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByID returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByID(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ID] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ID == v.ID {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].ID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ID] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByIDPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByIDPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ID]
			if !ok {
				resultMap[arrList[0][i].ID] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ID == v.ID {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].ID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ID] = true
			}
		}
	}
	return newList
}

// SubsetActivityByID returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByID(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].ID]
		if !ok {
			found := false
			resultMap[list1[i].ID] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].ID == list2[j].ID {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByIDPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByIDPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].ID]
		if !ok {
			found := false
			resultMap[list1[i].ID] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].ID == list2[j].ID {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByID returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByID(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].ID]
		if !ok {
			found := false
			resultMap[list2[i].ID] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].ID == list1[j].ID {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByIDPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByIDPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].ID]
		if !ok {
			found := false
			resultMap[list2[i].ID] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].ID == list1[j].ID {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByID returns a set of the distinct elements of coll.
func SetActivityByID(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[int64]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].ID]
		if !ok {
			resultMap[list[i].ID] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByIDPtr returns a set of the distinct elements of coll.
func SetActivityByIDPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[int64]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].ID]
		if !ok {
			resultMap[list[i].ID] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByResourceState return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByResourceState(arrList ...[]Activity) []Activity {
	resultMap := make(map[int]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.ResourceState]
			if !ok {
				resultMap[v.ResourceState] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByResourceStatePtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[int]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.ResourceState]
			if !ok {
				resultMap[v.ResourceState] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByResourceState return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByResourceState(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ResourceState]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ResourceState] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ResourceState == v.ResourceState {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].ResourceState]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ResourceState] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByResourceStatePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByResourceStatePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ResourceState]
			if !ok {
				resultMap[arrList[0][i].ResourceState] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ResourceState == v.ResourceState {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].ResourceState]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ResourceState] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByResourceState returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByResourceState(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ResourceState]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ResourceState] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ResourceState == v.ResourceState {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].ResourceState]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ResourceState] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByResourceStatePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByResourceStatePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ResourceState]
			if !ok {
				resultMap[arrList[0][i].ResourceState] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ResourceState == v.ResourceState {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].ResourceState]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ResourceState] = true
			}
		}
	}
	return newList
}

// SubsetActivityByResourceState returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByResourceState(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].ResourceState]
		if !ok {
			found := false
			resultMap[list1[i].ResourceState] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].ResourceState == list2[j].ResourceState {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByResourceStatePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByResourceStatePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].ResourceState]
		if !ok {
			found := false
			resultMap[list1[i].ResourceState] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].ResourceState == list2[j].ResourceState {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByResourceState returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByResourceState(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].ResourceState]
		if !ok {
			found := false
			resultMap[list2[i].ResourceState] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].ResourceState == list1[j].ResourceState {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByResourceStatePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByResourceStatePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].ResourceState]
		if !ok {
			found := false
			resultMap[list2[i].ResourceState] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].ResourceState == list1[j].ResourceState {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByResourceState returns a set of the distinct elements of coll.
func SetActivityByResourceState(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].ResourceState]
		if !ok {
			resultMap[list[i].ResourceState] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByResourceStatePtr returns a set of the distinct elements of coll.
func SetActivityByResourceStatePtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].ResourceState]
		if !ok {
			resultMap[list[i].ResourceState] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByExternalID return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByExternalID(arrList ...[]Activity) []Activity {
	resultMap := make(map[string]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.ExternalID]
			if !ok {
				resultMap[v.ExternalID] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByExternalIDPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[string]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.ExternalID]
			if !ok {
				resultMap[v.ExternalID] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByExternalID return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByExternalID(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ExternalID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ExternalID] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ExternalID == v.ExternalID {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].ExternalID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ExternalID] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByExternalIDPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByExternalIDPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ExternalID]
			if !ok {
				resultMap[arrList[0][i].ExternalID] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ExternalID == v.ExternalID {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].ExternalID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ExternalID] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByExternalID returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByExternalID(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ExternalID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ExternalID] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ExternalID == v.ExternalID {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].ExternalID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ExternalID] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByExternalIDPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByExternalIDPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ExternalID]
			if !ok {
				resultMap[arrList[0][i].ExternalID] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ExternalID == v.ExternalID {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].ExternalID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ExternalID] = true
			}
		}
	}
	return newList
}

// SubsetActivityByExternalID returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByExternalID(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].ExternalID]
		if !ok {
			found := false
			resultMap[list1[i].ExternalID] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].ExternalID == list2[j].ExternalID {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByExternalIDPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByExternalIDPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].ExternalID]
		if !ok {
			found := false
			resultMap[list1[i].ExternalID] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].ExternalID == list2[j].ExternalID {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByExternalID returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByExternalID(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].ExternalID]
		if !ok {
			found := false
			resultMap[list2[i].ExternalID] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].ExternalID == list1[j].ExternalID {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByExternalIDPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByExternalIDPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].ExternalID]
		if !ok {
			found := false
			resultMap[list2[i].ExternalID] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].ExternalID == list1[j].ExternalID {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByExternalID returns a set of the distinct elements of coll.
func SetActivityByExternalID(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].ExternalID]
		if !ok {
			resultMap[list[i].ExternalID] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByExternalIDPtr returns a set of the distinct elements of coll.
func SetActivityByExternalIDPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].ExternalID]
		if !ok {
			resultMap[list[i].ExternalID] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByUploadID return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByUploadID(arrList ...[]Activity) []Activity {
	resultMap := make(map[int64]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.UploadID]
			if !ok {
				resultMap[v.UploadID] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByUploadIDPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[int64]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.UploadID]
			if !ok {
				resultMap[v.UploadID] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByUploadID return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByUploadID(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].UploadID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].UploadID] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].UploadID == v.UploadID {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].UploadID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].UploadID] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByUploadIDPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByUploadIDPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].UploadID]
			if !ok {
				resultMap[arrList[0][i].UploadID] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].UploadID == v.UploadID {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].UploadID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].UploadID] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByUploadID returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByUploadID(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].UploadID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].UploadID] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].UploadID == v.UploadID {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].UploadID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].UploadID] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByUploadIDPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByUploadIDPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].UploadID]
			if !ok {
				resultMap[arrList[0][i].UploadID] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].UploadID == v.UploadID {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].UploadID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].UploadID] = true
			}
		}
	}
	return newList
}

// SubsetActivityByUploadID returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByUploadID(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].UploadID]
		if !ok {
			found := false
			resultMap[list1[i].UploadID] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].UploadID == list2[j].UploadID {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByUploadIDPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByUploadIDPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].UploadID]
		if !ok {
			found := false
			resultMap[list1[i].UploadID] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].UploadID == list2[j].UploadID {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByUploadID returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByUploadID(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].UploadID]
		if !ok {
			found := false
			resultMap[list2[i].UploadID] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].UploadID == list1[j].UploadID {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByUploadIDPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByUploadIDPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].UploadID]
		if !ok {
			found := false
			resultMap[list2[i].UploadID] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].UploadID == list1[j].UploadID {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByUploadID returns a set of the distinct elements of coll.
func SetActivityByUploadID(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[int64]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].UploadID]
		if !ok {
			resultMap[list[i].UploadID] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByUploadIDPtr returns a set of the distinct elements of coll.
func SetActivityByUploadIDPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[int64]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].UploadID]
		if !ok {
			resultMap[list[i].UploadID] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByName return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByName(arrList ...[]Activity) []Activity {
	resultMap := make(map[string]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Name]
			if !ok {
				resultMap[v.Name] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByNamePtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[string]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Name]
			if !ok {
				resultMap[v.Name] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByName return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByName(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Name] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Name == v.Name {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Name] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByNamePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByNamePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				resultMap[arrList[0][i].Name] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Name == v.Name {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Name] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByName returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByName(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Name] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Name == v.Name {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Name] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByNamePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByNamePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				resultMap[arrList[0][i].Name] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Name == v.Name {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Name]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Name] = true
			}
		}
	}
	return newList
}

// SubsetActivityByName returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByName(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Name]
		if !ok {
			found := false
			resultMap[list1[i].Name] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Name == list2[j].Name {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByNamePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByNamePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Name]
		if !ok {
			found := false
			resultMap[list1[i].Name] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Name == list2[j].Name {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByName returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByName(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Name]
		if !ok {
			found := false
			resultMap[list2[i].Name] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Name == list1[j].Name {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByNamePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByNamePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Name]
		if !ok {
			found := false
			resultMap[list2[i].Name] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Name == list1[j].Name {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByName returns a set of the distinct elements of coll.
func SetActivityByName(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Name]
		if !ok {
			resultMap[list[i].Name] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByNamePtr returns a set of the distinct elements of coll.
func SetActivityByNamePtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Name]
		if !ok {
			resultMap[list[i].Name] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByDistance return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByDistance(arrList ...[]Activity) []Activity {
	resultMap := make(map[float64]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Distance]
			if !ok {
				resultMap[v.Distance] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByDistancePtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[float64]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Distance]
			if !ok {
				resultMap[v.Distance] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByDistance return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByDistance(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Distance]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Distance] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Distance == v.Distance {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Distance]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Distance] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByDistancePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByDistancePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Distance]
			if !ok {
				resultMap[arrList[0][i].Distance] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Distance == v.Distance {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Distance]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Distance] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByDistance returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByDistance(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Distance]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Distance] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Distance == v.Distance {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Distance]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Distance] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByDistancePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByDistancePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Distance]
			if !ok {
				resultMap[arrList[0][i].Distance] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Distance == v.Distance {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Distance]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Distance] = true
			}
		}
	}
	return newList
}

// SubsetActivityByDistance returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByDistance(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Distance]
		if !ok {
			found := false
			resultMap[list1[i].Distance] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Distance == list2[j].Distance {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByDistancePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByDistancePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Distance]
		if !ok {
			found := false
			resultMap[list1[i].Distance] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Distance == list2[j].Distance {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByDistance returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByDistance(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Distance]
		if !ok {
			found := false
			resultMap[list2[i].Distance] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Distance == list1[j].Distance {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByDistancePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByDistancePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Distance]
		if !ok {
			found := false
			resultMap[list2[i].Distance] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Distance == list1[j].Distance {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByDistance returns a set of the distinct elements of coll.
func SetActivityByDistance(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Distance]
		if !ok {
			resultMap[list[i].Distance] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByDistancePtr returns a set of the distinct elements of coll.
func SetActivityByDistancePtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Distance]
		if !ok {
			resultMap[list[i].Distance] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByMovingTime return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByMovingTime(arrList ...[]Activity) []Activity {
	resultMap := make(map[int]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.MovingTime]
			if !ok {
				resultMap[v.MovingTime] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByMovingTimePtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[int]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.MovingTime]
			if !ok {
				resultMap[v.MovingTime] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByMovingTime return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByMovingTime(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].MovingTime]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].MovingTime] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].MovingTime == v.MovingTime {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].MovingTime]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].MovingTime] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByMovingTimePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByMovingTimePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].MovingTime]
			if !ok {
				resultMap[arrList[0][i].MovingTime] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].MovingTime == v.MovingTime {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].MovingTime]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].MovingTime] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByMovingTime returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByMovingTime(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].MovingTime]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].MovingTime] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].MovingTime == v.MovingTime {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].MovingTime]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].MovingTime] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByMovingTimePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByMovingTimePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].MovingTime]
			if !ok {
				resultMap[arrList[0][i].MovingTime] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].MovingTime == v.MovingTime {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].MovingTime]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].MovingTime] = true
			}
		}
	}
	return newList
}

// SubsetActivityByMovingTime returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByMovingTime(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].MovingTime]
		if !ok {
			found := false
			resultMap[list1[i].MovingTime] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].MovingTime == list2[j].MovingTime {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByMovingTimePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByMovingTimePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].MovingTime]
		if !ok {
			found := false
			resultMap[list1[i].MovingTime] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].MovingTime == list2[j].MovingTime {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByMovingTime returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByMovingTime(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].MovingTime]
		if !ok {
			found := false
			resultMap[list2[i].MovingTime] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].MovingTime == list1[j].MovingTime {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByMovingTimePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByMovingTimePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].MovingTime]
		if !ok {
			found := false
			resultMap[list2[i].MovingTime] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].MovingTime == list1[j].MovingTime {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByMovingTime returns a set of the distinct elements of coll.
func SetActivityByMovingTime(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].MovingTime]
		if !ok {
			resultMap[list[i].MovingTime] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByMovingTimePtr returns a set of the distinct elements of coll.
func SetActivityByMovingTimePtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].MovingTime]
		if !ok {
			resultMap[list[i].MovingTime] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByElapsedTime return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByElapsedTime(arrList ...[]Activity) []Activity {
	resultMap := make(map[int]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.ElapsedTime]
			if !ok {
				resultMap[v.ElapsedTime] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByElapsedTimePtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[int]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.ElapsedTime]
			if !ok {
				resultMap[v.ElapsedTime] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByElapsedTime return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByElapsedTime(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ElapsedTime]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ElapsedTime] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ElapsedTime == v.ElapsedTime {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].ElapsedTime]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ElapsedTime] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByElapsedTimePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByElapsedTimePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ElapsedTime]
			if !ok {
				resultMap[arrList[0][i].ElapsedTime] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ElapsedTime == v.ElapsedTime {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].ElapsedTime]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ElapsedTime] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByElapsedTime returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByElapsedTime(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ElapsedTime]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ElapsedTime] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ElapsedTime == v.ElapsedTime {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].ElapsedTime]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ElapsedTime] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByElapsedTimePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByElapsedTimePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ElapsedTime]
			if !ok {
				resultMap[arrList[0][i].ElapsedTime] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ElapsedTime == v.ElapsedTime {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].ElapsedTime]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ElapsedTime] = true
			}
		}
	}
	return newList
}

// SubsetActivityByElapsedTime returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByElapsedTime(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].ElapsedTime]
		if !ok {
			found := false
			resultMap[list1[i].ElapsedTime] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].ElapsedTime == list2[j].ElapsedTime {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByElapsedTimePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByElapsedTimePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].ElapsedTime]
		if !ok {
			found := false
			resultMap[list1[i].ElapsedTime] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].ElapsedTime == list2[j].ElapsedTime {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByElapsedTime returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByElapsedTime(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].ElapsedTime]
		if !ok {
			found := false
			resultMap[list2[i].ElapsedTime] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].ElapsedTime == list1[j].ElapsedTime {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByElapsedTimePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByElapsedTimePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].ElapsedTime]
		if !ok {
			found := false
			resultMap[list2[i].ElapsedTime] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].ElapsedTime == list1[j].ElapsedTime {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByElapsedTime returns a set of the distinct elements of coll.
func SetActivityByElapsedTime(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].ElapsedTime]
		if !ok {
			resultMap[list[i].ElapsedTime] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByElapsedTimePtr returns a set of the distinct elements of coll.
func SetActivityByElapsedTimePtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].ElapsedTime]
		if !ok {
			resultMap[list[i].ElapsedTime] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByTotalElevationGain return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByTotalElevationGain(arrList ...[]Activity) []Activity {
	resultMap := make(map[float64]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.TotalElevationGain]
			if !ok {
				resultMap[v.TotalElevationGain] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByTotalElevationGainPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[float64]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.TotalElevationGain]
			if !ok {
				resultMap[v.TotalElevationGain] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByTotalElevationGain return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByTotalElevationGain(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].TotalElevationGain]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].TotalElevationGain] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].TotalElevationGain == v.TotalElevationGain {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].TotalElevationGain]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].TotalElevationGain] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByTotalElevationGainPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByTotalElevationGainPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].TotalElevationGain]
			if !ok {
				resultMap[arrList[0][i].TotalElevationGain] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].TotalElevationGain == v.TotalElevationGain {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].TotalElevationGain]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].TotalElevationGain] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByTotalElevationGain returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByTotalElevationGain(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].TotalElevationGain]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].TotalElevationGain] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].TotalElevationGain == v.TotalElevationGain {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].TotalElevationGain]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].TotalElevationGain] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByTotalElevationGainPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByTotalElevationGainPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].TotalElevationGain]
			if !ok {
				resultMap[arrList[0][i].TotalElevationGain] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].TotalElevationGain == v.TotalElevationGain {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].TotalElevationGain]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].TotalElevationGain] = true
			}
		}
	}
	return newList
}

// SubsetActivityByTotalElevationGain returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByTotalElevationGain(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].TotalElevationGain]
		if !ok {
			found := false
			resultMap[list1[i].TotalElevationGain] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].TotalElevationGain == list2[j].TotalElevationGain {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByTotalElevationGainPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByTotalElevationGainPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].TotalElevationGain]
		if !ok {
			found := false
			resultMap[list1[i].TotalElevationGain] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].TotalElevationGain == list2[j].TotalElevationGain {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByTotalElevationGain returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByTotalElevationGain(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].TotalElevationGain]
		if !ok {
			found := false
			resultMap[list2[i].TotalElevationGain] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].TotalElevationGain == list1[j].TotalElevationGain {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByTotalElevationGainPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByTotalElevationGainPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].TotalElevationGain]
		if !ok {
			found := false
			resultMap[list2[i].TotalElevationGain] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].TotalElevationGain == list1[j].TotalElevationGain {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByTotalElevationGain returns a set of the distinct elements of coll.
func SetActivityByTotalElevationGain(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].TotalElevationGain]
		if !ok {
			resultMap[list[i].TotalElevationGain] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByTotalElevationGainPtr returns a set of the distinct elements of coll.
func SetActivityByTotalElevationGainPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].TotalElevationGain]
		if !ok {
			resultMap[list[i].TotalElevationGain] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByType return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByType(arrList ...[]Activity) []Activity {
	resultMap := make(map[string]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Type]
			if !ok {
				resultMap[v.Type] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByTypePtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[string]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Type]
			if !ok {
				resultMap[v.Type] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByType return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByType(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Type]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Type] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Type == v.Type {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Type]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Type] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByTypePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByTypePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Type]
			if !ok {
				resultMap[arrList[0][i].Type] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Type == v.Type {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Type]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Type] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByType returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByType(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Type]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Type] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Type == v.Type {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Type]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Type] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByTypePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByTypePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Type]
			if !ok {
				resultMap[arrList[0][i].Type] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Type == v.Type {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Type]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Type] = true
			}
		}
	}
	return newList
}

// SubsetActivityByType returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByType(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Type]
		if !ok {
			found := false
			resultMap[list1[i].Type] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Type == list2[j].Type {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByTypePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByTypePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Type]
		if !ok {
			found := false
			resultMap[list1[i].Type] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Type == list2[j].Type {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByType returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByType(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Type]
		if !ok {
			found := false
			resultMap[list2[i].Type] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Type == list1[j].Type {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByTypePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByTypePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Type]
		if !ok {
			found := false
			resultMap[list2[i].Type] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Type == list1[j].Type {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByType returns a set of the distinct elements of coll.
func SetActivityByType(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Type]
		if !ok {
			resultMap[list[i].Type] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByTypePtr returns a set of the distinct elements of coll.
func SetActivityByTypePtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Type]
		if !ok {
			resultMap[list[i].Type] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByStartDate return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByStartDate(arrList ...[]Activity) []Activity {
	resultMap := make(map[time.Time]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.StartDate]
			if !ok {
				resultMap[v.StartDate] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByStartDatePtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[time.Time]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.StartDate]
			if !ok {
				resultMap[v.StartDate] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByStartDate return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByStartDate(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].StartDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].StartDate] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].StartDate == v.StartDate {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].StartDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].StartDate] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByStartDatePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByStartDatePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].StartDate]
			if !ok {
				resultMap[arrList[0][i].StartDate] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].StartDate == v.StartDate {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].StartDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].StartDate] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByStartDate returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByStartDate(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].StartDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].StartDate] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].StartDate == v.StartDate {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].StartDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].StartDate] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByStartDatePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByStartDatePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].StartDate]
			if !ok {
				resultMap[arrList[0][i].StartDate] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].StartDate == v.StartDate {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].StartDate]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].StartDate] = true
			}
		}
	}
	return newList
}

// SubsetActivityByStartDate returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByStartDate(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].StartDate]
		if !ok {
			found := false
			resultMap[list1[i].StartDate] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].StartDate == list2[j].StartDate {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByStartDatePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByStartDatePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].StartDate]
		if !ok {
			found := false
			resultMap[list1[i].StartDate] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].StartDate == list2[j].StartDate {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByStartDate returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByStartDate(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].StartDate]
		if !ok {
			found := false
			resultMap[list2[i].StartDate] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].StartDate == list1[j].StartDate {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByStartDatePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByStartDatePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].StartDate]
		if !ok {
			found := false
			resultMap[list2[i].StartDate] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].StartDate == list1[j].StartDate {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByStartDate returns a set of the distinct elements of coll.
func SetActivityByStartDate(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[time.Time]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].StartDate]
		if !ok {
			resultMap[list[i].StartDate] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByStartDatePtr returns a set of the distinct elements of coll.
func SetActivityByStartDatePtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[time.Time]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].StartDate]
		if !ok {
			resultMap[list[i].StartDate] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByStartDateLocal return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByStartDateLocal(arrList ...[]Activity) []Activity {
	resultMap := make(map[time.Time]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.StartDateLocal]
			if !ok {
				resultMap[v.StartDateLocal] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByStartDateLocalPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[time.Time]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.StartDateLocal]
			if !ok {
				resultMap[v.StartDateLocal] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByStartDateLocal return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByStartDateLocal(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].StartDateLocal]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].StartDateLocal] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].StartDateLocal == v.StartDateLocal {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].StartDateLocal]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].StartDateLocal] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByStartDateLocalPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByStartDateLocalPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].StartDateLocal]
			if !ok {
				resultMap[arrList[0][i].StartDateLocal] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].StartDateLocal == v.StartDateLocal {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].StartDateLocal]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].StartDateLocal] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByStartDateLocal returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByStartDateLocal(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].StartDateLocal]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].StartDateLocal] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].StartDateLocal == v.StartDateLocal {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].StartDateLocal]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].StartDateLocal] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByStartDateLocalPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByStartDateLocalPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[time.Time]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].StartDateLocal]
			if !ok {
				resultMap[arrList[0][i].StartDateLocal] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].StartDateLocal == v.StartDateLocal {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].StartDateLocal]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].StartDateLocal] = true
			}
		}
	}
	return newList
}

// SubsetActivityByStartDateLocal returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByStartDateLocal(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].StartDateLocal]
		if !ok {
			found := false
			resultMap[list1[i].StartDateLocal] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].StartDateLocal == list2[j].StartDateLocal {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByStartDateLocalPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByStartDateLocalPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].StartDateLocal]
		if !ok {
			found := false
			resultMap[list1[i].StartDateLocal] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].StartDateLocal == list2[j].StartDateLocal {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByStartDateLocal returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByStartDateLocal(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].StartDateLocal]
		if !ok {
			found := false
			resultMap[list2[i].StartDateLocal] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].StartDateLocal == list1[j].StartDateLocal {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByStartDateLocalPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByStartDateLocalPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[time.Time]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].StartDateLocal]
		if !ok {
			found := false
			resultMap[list2[i].StartDateLocal] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].StartDateLocal == list1[j].StartDateLocal {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByStartDateLocal returns a set of the distinct elements of coll.
func SetActivityByStartDateLocal(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[time.Time]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].StartDateLocal]
		if !ok {
			resultMap[list[i].StartDateLocal] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByStartDateLocalPtr returns a set of the distinct elements of coll.
func SetActivityByStartDateLocalPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[time.Time]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].StartDateLocal]
		if !ok {
			resultMap[list[i].StartDateLocal] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByTimezone return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByTimezone(arrList ...[]Activity) []Activity {
	resultMap := make(map[string]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Timezone]
			if !ok {
				resultMap[v.Timezone] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByTimezonePtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[string]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Timezone]
			if !ok {
				resultMap[v.Timezone] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByTimezone return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByTimezone(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Timezone]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Timezone] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Timezone == v.Timezone {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Timezone]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Timezone] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByTimezonePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByTimezonePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Timezone]
			if !ok {
				resultMap[arrList[0][i].Timezone] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Timezone == v.Timezone {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Timezone]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Timezone] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByTimezone returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByTimezone(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Timezone]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Timezone] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Timezone == v.Timezone {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Timezone]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Timezone] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByTimezonePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByTimezonePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Timezone]
			if !ok {
				resultMap[arrList[0][i].Timezone] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Timezone == v.Timezone {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Timezone]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Timezone] = true
			}
		}
	}
	return newList
}

// SubsetActivityByTimezone returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByTimezone(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Timezone]
		if !ok {
			found := false
			resultMap[list1[i].Timezone] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Timezone == list2[j].Timezone {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByTimezonePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByTimezonePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Timezone]
		if !ok {
			found := false
			resultMap[list1[i].Timezone] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Timezone == list2[j].Timezone {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByTimezone returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByTimezone(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Timezone]
		if !ok {
			found := false
			resultMap[list2[i].Timezone] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Timezone == list1[j].Timezone {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByTimezonePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByTimezonePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Timezone]
		if !ok {
			found := false
			resultMap[list2[i].Timezone] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Timezone == list1[j].Timezone {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByTimezone returns a set of the distinct elements of coll.
func SetActivityByTimezone(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Timezone]
		if !ok {
			resultMap[list[i].Timezone] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByTimezonePtr returns a set of the distinct elements of coll.
func SetActivityByTimezonePtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Timezone]
		if !ok {
			resultMap[list[i].Timezone] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByUtcOffset return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByUtcOffset(arrList ...[]Activity) []Activity {
	resultMap := make(map[float64]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.UtcOffset]
			if !ok {
				resultMap[v.UtcOffset] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByUtcOffsetPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[float64]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.UtcOffset]
			if !ok {
				resultMap[v.UtcOffset] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByUtcOffset return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByUtcOffset(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].UtcOffset]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].UtcOffset] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].UtcOffset == v.UtcOffset {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].UtcOffset]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].UtcOffset] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByUtcOffsetPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByUtcOffsetPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].UtcOffset]
			if !ok {
				resultMap[arrList[0][i].UtcOffset] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].UtcOffset == v.UtcOffset {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].UtcOffset]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].UtcOffset] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByUtcOffset returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByUtcOffset(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].UtcOffset]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].UtcOffset] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].UtcOffset == v.UtcOffset {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].UtcOffset]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].UtcOffset] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByUtcOffsetPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByUtcOffsetPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].UtcOffset]
			if !ok {
				resultMap[arrList[0][i].UtcOffset] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].UtcOffset == v.UtcOffset {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].UtcOffset]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].UtcOffset] = true
			}
		}
	}
	return newList
}

// SubsetActivityByUtcOffset returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByUtcOffset(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].UtcOffset]
		if !ok {
			found := false
			resultMap[list1[i].UtcOffset] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].UtcOffset == list2[j].UtcOffset {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByUtcOffsetPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByUtcOffsetPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].UtcOffset]
		if !ok {
			found := false
			resultMap[list1[i].UtcOffset] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].UtcOffset == list2[j].UtcOffset {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByUtcOffset returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByUtcOffset(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].UtcOffset]
		if !ok {
			found := false
			resultMap[list2[i].UtcOffset] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].UtcOffset == list1[j].UtcOffset {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByUtcOffsetPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByUtcOffsetPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].UtcOffset]
		if !ok {
			found := false
			resultMap[list2[i].UtcOffset] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].UtcOffset == list1[j].UtcOffset {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByUtcOffset returns a set of the distinct elements of coll.
func SetActivityByUtcOffset(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].UtcOffset]
		if !ok {
			resultMap[list[i].UtcOffset] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByUtcOffsetPtr returns a set of the distinct elements of coll.
func SetActivityByUtcOffsetPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].UtcOffset]
		if !ok {
			resultMap[list[i].UtcOffset] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByLocationCity return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByLocationCity(arrList ...[]Activity) []Activity {
	resultMap := make(map[string]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.LocationCity]
			if !ok {
				resultMap[v.LocationCity] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByLocationCityPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[string]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.LocationCity]
			if !ok {
				resultMap[v.LocationCity] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByLocationCity return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByLocationCity(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].LocationCity]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].LocationCity] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].LocationCity == v.LocationCity {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].LocationCity]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].LocationCity] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByLocationCityPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByLocationCityPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].LocationCity]
			if !ok {
				resultMap[arrList[0][i].LocationCity] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].LocationCity == v.LocationCity {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].LocationCity]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].LocationCity] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByLocationCity returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByLocationCity(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].LocationCity]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].LocationCity] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].LocationCity == v.LocationCity {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].LocationCity]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].LocationCity] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByLocationCityPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByLocationCityPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].LocationCity]
			if !ok {
				resultMap[arrList[0][i].LocationCity] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].LocationCity == v.LocationCity {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].LocationCity]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].LocationCity] = true
			}
		}
	}
	return newList
}

// SubsetActivityByLocationCity returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByLocationCity(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].LocationCity]
		if !ok {
			found := false
			resultMap[list1[i].LocationCity] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].LocationCity == list2[j].LocationCity {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByLocationCityPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByLocationCityPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].LocationCity]
		if !ok {
			found := false
			resultMap[list1[i].LocationCity] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].LocationCity == list2[j].LocationCity {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByLocationCity returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByLocationCity(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].LocationCity]
		if !ok {
			found := false
			resultMap[list2[i].LocationCity] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].LocationCity == list1[j].LocationCity {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByLocationCityPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByLocationCityPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].LocationCity]
		if !ok {
			found := false
			resultMap[list2[i].LocationCity] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].LocationCity == list1[j].LocationCity {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByLocationCity returns a set of the distinct elements of coll.
func SetActivityByLocationCity(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].LocationCity]
		if !ok {
			resultMap[list[i].LocationCity] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByLocationCityPtr returns a set of the distinct elements of coll.
func SetActivityByLocationCityPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].LocationCity]
		if !ok {
			resultMap[list[i].LocationCity] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByLocationState return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByLocationState(arrList ...[]Activity) []Activity {
	resultMap := make(map[string]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.LocationState]
			if !ok {
				resultMap[v.LocationState] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByLocationStatePtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[string]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.LocationState]
			if !ok {
				resultMap[v.LocationState] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByLocationState return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByLocationState(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].LocationState]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].LocationState] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].LocationState == v.LocationState {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].LocationState]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].LocationState] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByLocationStatePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByLocationStatePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].LocationState]
			if !ok {
				resultMap[arrList[0][i].LocationState] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].LocationState == v.LocationState {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].LocationState]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].LocationState] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByLocationState returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByLocationState(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].LocationState]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].LocationState] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].LocationState == v.LocationState {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].LocationState]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].LocationState] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByLocationStatePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByLocationStatePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].LocationState]
			if !ok {
				resultMap[arrList[0][i].LocationState] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].LocationState == v.LocationState {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].LocationState]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].LocationState] = true
			}
		}
	}
	return newList
}

// SubsetActivityByLocationState returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByLocationState(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].LocationState]
		if !ok {
			found := false
			resultMap[list1[i].LocationState] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].LocationState == list2[j].LocationState {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByLocationStatePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByLocationStatePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].LocationState]
		if !ok {
			found := false
			resultMap[list1[i].LocationState] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].LocationState == list2[j].LocationState {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByLocationState returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByLocationState(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].LocationState]
		if !ok {
			found := false
			resultMap[list2[i].LocationState] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].LocationState == list1[j].LocationState {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByLocationStatePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByLocationStatePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].LocationState]
		if !ok {
			found := false
			resultMap[list2[i].LocationState] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].LocationState == list1[j].LocationState {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByLocationState returns a set of the distinct elements of coll.
func SetActivityByLocationState(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].LocationState]
		if !ok {
			resultMap[list[i].LocationState] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByLocationStatePtr returns a set of the distinct elements of coll.
func SetActivityByLocationStatePtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].LocationState]
		if !ok {
			resultMap[list[i].LocationState] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByLocationCountry return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByLocationCountry(arrList ...[]Activity) []Activity {
	resultMap := make(map[string]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.LocationCountry]
			if !ok {
				resultMap[v.LocationCountry] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByLocationCountryPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[string]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.LocationCountry]
			if !ok {
				resultMap[v.LocationCountry] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByLocationCountry return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByLocationCountry(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].LocationCountry]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].LocationCountry] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].LocationCountry == v.LocationCountry {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].LocationCountry]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].LocationCountry] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByLocationCountryPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByLocationCountryPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].LocationCountry]
			if !ok {
				resultMap[arrList[0][i].LocationCountry] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].LocationCountry == v.LocationCountry {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].LocationCountry]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].LocationCountry] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByLocationCountry returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByLocationCountry(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].LocationCountry]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].LocationCountry] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].LocationCountry == v.LocationCountry {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].LocationCountry]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].LocationCountry] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByLocationCountryPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByLocationCountryPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].LocationCountry]
			if !ok {
				resultMap[arrList[0][i].LocationCountry] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].LocationCountry == v.LocationCountry {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].LocationCountry]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].LocationCountry] = true
			}
		}
	}
	return newList
}

// SubsetActivityByLocationCountry returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByLocationCountry(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].LocationCountry]
		if !ok {
			found := false
			resultMap[list1[i].LocationCountry] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].LocationCountry == list2[j].LocationCountry {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByLocationCountryPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByLocationCountryPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].LocationCountry]
		if !ok {
			found := false
			resultMap[list1[i].LocationCountry] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].LocationCountry == list2[j].LocationCountry {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByLocationCountry returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByLocationCountry(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].LocationCountry]
		if !ok {
			found := false
			resultMap[list2[i].LocationCountry] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].LocationCountry == list1[j].LocationCountry {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByLocationCountryPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByLocationCountryPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].LocationCountry]
		if !ok {
			found := false
			resultMap[list2[i].LocationCountry] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].LocationCountry == list1[j].LocationCountry {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByLocationCountry returns a set of the distinct elements of coll.
func SetActivityByLocationCountry(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].LocationCountry]
		if !ok {
			resultMap[list[i].LocationCountry] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByLocationCountryPtr returns a set of the distinct elements of coll.
func SetActivityByLocationCountryPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].LocationCountry]
		if !ok {
			resultMap[list[i].LocationCountry] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByAchievementCount return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByAchievementCount(arrList ...[]Activity) []Activity {
	resultMap := make(map[int]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.AchievementCount]
			if !ok {
				resultMap[v.AchievementCount] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByAchievementCountPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[int]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.AchievementCount]
			if !ok {
				resultMap[v.AchievementCount] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByAchievementCount return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByAchievementCount(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AchievementCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AchievementCount] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AchievementCount == v.AchievementCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].AchievementCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AchievementCount] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByAchievementCountPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByAchievementCountPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AchievementCount]
			if !ok {
				resultMap[arrList[0][i].AchievementCount] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AchievementCount == v.AchievementCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].AchievementCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AchievementCount] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByAchievementCount returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByAchievementCount(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AchievementCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AchievementCount] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AchievementCount == v.AchievementCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].AchievementCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AchievementCount] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByAchievementCountPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByAchievementCountPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AchievementCount]
			if !ok {
				resultMap[arrList[0][i].AchievementCount] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AchievementCount == v.AchievementCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].AchievementCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AchievementCount] = true
			}
		}
	}
	return newList
}

// SubsetActivityByAchievementCount returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByAchievementCount(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].AchievementCount]
		if !ok {
			found := false
			resultMap[list1[i].AchievementCount] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].AchievementCount == list2[j].AchievementCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByAchievementCountPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByAchievementCountPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].AchievementCount]
		if !ok {
			found := false
			resultMap[list1[i].AchievementCount] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].AchievementCount == list2[j].AchievementCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByAchievementCount returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByAchievementCount(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].AchievementCount]
		if !ok {
			found := false
			resultMap[list2[i].AchievementCount] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].AchievementCount == list1[j].AchievementCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByAchievementCountPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByAchievementCountPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].AchievementCount]
		if !ok {
			found := false
			resultMap[list2[i].AchievementCount] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].AchievementCount == list1[j].AchievementCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByAchievementCount returns a set of the distinct elements of coll.
func SetActivityByAchievementCount(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].AchievementCount]
		if !ok {
			resultMap[list[i].AchievementCount] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByAchievementCountPtr returns a set of the distinct elements of coll.
func SetActivityByAchievementCountPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].AchievementCount]
		if !ok {
			resultMap[list[i].AchievementCount] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByKudosCount return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByKudosCount(arrList ...[]Activity) []Activity {
	resultMap := make(map[int]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.KudosCount]
			if !ok {
				resultMap[v.KudosCount] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByKudosCountPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[int]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.KudosCount]
			if !ok {
				resultMap[v.KudosCount] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByKudosCount return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByKudosCount(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].KudosCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].KudosCount] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].KudosCount == v.KudosCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].KudosCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].KudosCount] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByKudosCountPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByKudosCountPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].KudosCount]
			if !ok {
				resultMap[arrList[0][i].KudosCount] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].KudosCount == v.KudosCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].KudosCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].KudosCount] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByKudosCount returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByKudosCount(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].KudosCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].KudosCount] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].KudosCount == v.KudosCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].KudosCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].KudosCount] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByKudosCountPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByKudosCountPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].KudosCount]
			if !ok {
				resultMap[arrList[0][i].KudosCount] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].KudosCount == v.KudosCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].KudosCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].KudosCount] = true
			}
		}
	}
	return newList
}

// SubsetActivityByKudosCount returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByKudosCount(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].KudosCount]
		if !ok {
			found := false
			resultMap[list1[i].KudosCount] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].KudosCount == list2[j].KudosCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByKudosCountPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByKudosCountPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].KudosCount]
		if !ok {
			found := false
			resultMap[list1[i].KudosCount] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].KudosCount == list2[j].KudosCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByKudosCount returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByKudosCount(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].KudosCount]
		if !ok {
			found := false
			resultMap[list2[i].KudosCount] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].KudosCount == list1[j].KudosCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByKudosCountPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByKudosCountPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].KudosCount]
		if !ok {
			found := false
			resultMap[list2[i].KudosCount] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].KudosCount == list1[j].KudosCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByKudosCount returns a set of the distinct elements of coll.
func SetActivityByKudosCount(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].KudosCount]
		if !ok {
			resultMap[list[i].KudosCount] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByKudosCountPtr returns a set of the distinct elements of coll.
func SetActivityByKudosCountPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].KudosCount]
		if !ok {
			resultMap[list[i].KudosCount] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByCommentCount return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByCommentCount(arrList ...[]Activity) []Activity {
	resultMap := make(map[int]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.CommentCount]
			if !ok {
				resultMap[v.CommentCount] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByCommentCountPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[int]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.CommentCount]
			if !ok {
				resultMap[v.CommentCount] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByCommentCount return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByCommentCount(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].CommentCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CommentCount] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].CommentCount == v.CommentCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].CommentCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CommentCount] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByCommentCountPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByCommentCountPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].CommentCount]
			if !ok {
				resultMap[arrList[0][i].CommentCount] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].CommentCount == v.CommentCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].CommentCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CommentCount] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByCommentCount returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByCommentCount(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].CommentCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CommentCount] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].CommentCount == v.CommentCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].CommentCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CommentCount] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByCommentCountPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByCommentCountPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].CommentCount]
			if !ok {
				resultMap[arrList[0][i].CommentCount] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].CommentCount == v.CommentCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].CommentCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].CommentCount] = true
			}
		}
	}
	return newList
}

// SubsetActivityByCommentCount returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByCommentCount(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].CommentCount]
		if !ok {
			found := false
			resultMap[list1[i].CommentCount] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].CommentCount == list2[j].CommentCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByCommentCountPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByCommentCountPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].CommentCount]
		if !ok {
			found := false
			resultMap[list1[i].CommentCount] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].CommentCount == list2[j].CommentCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByCommentCount returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByCommentCount(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].CommentCount]
		if !ok {
			found := false
			resultMap[list2[i].CommentCount] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].CommentCount == list1[j].CommentCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByCommentCountPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByCommentCountPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].CommentCount]
		if !ok {
			found := false
			resultMap[list2[i].CommentCount] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].CommentCount == list1[j].CommentCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByCommentCount returns a set of the distinct elements of coll.
func SetActivityByCommentCount(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].CommentCount]
		if !ok {
			resultMap[list[i].CommentCount] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByCommentCountPtr returns a set of the distinct elements of coll.
func SetActivityByCommentCountPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].CommentCount]
		if !ok {
			resultMap[list[i].CommentCount] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByAthleteCount return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByAthleteCount(arrList ...[]Activity) []Activity {
	resultMap := make(map[int]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.AthleteCount]
			if !ok {
				resultMap[v.AthleteCount] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByAthleteCountPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[int]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.AthleteCount]
			if !ok {
				resultMap[v.AthleteCount] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByAthleteCount return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByAthleteCount(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AthleteCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AthleteCount] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AthleteCount == v.AthleteCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].AthleteCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AthleteCount] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByAthleteCountPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByAthleteCountPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AthleteCount]
			if !ok {
				resultMap[arrList[0][i].AthleteCount] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AthleteCount == v.AthleteCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].AthleteCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AthleteCount] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByAthleteCount returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByAthleteCount(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AthleteCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AthleteCount] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AthleteCount == v.AthleteCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].AthleteCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AthleteCount] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByAthleteCountPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByAthleteCountPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AthleteCount]
			if !ok {
				resultMap[arrList[0][i].AthleteCount] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AthleteCount == v.AthleteCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].AthleteCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AthleteCount] = true
			}
		}
	}
	return newList
}

// SubsetActivityByAthleteCount returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByAthleteCount(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].AthleteCount]
		if !ok {
			found := false
			resultMap[list1[i].AthleteCount] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].AthleteCount == list2[j].AthleteCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByAthleteCountPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByAthleteCountPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].AthleteCount]
		if !ok {
			found := false
			resultMap[list1[i].AthleteCount] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].AthleteCount == list2[j].AthleteCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByAthleteCount returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByAthleteCount(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].AthleteCount]
		if !ok {
			found := false
			resultMap[list2[i].AthleteCount] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].AthleteCount == list1[j].AthleteCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByAthleteCountPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByAthleteCountPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].AthleteCount]
		if !ok {
			found := false
			resultMap[list2[i].AthleteCount] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].AthleteCount == list1[j].AthleteCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByAthleteCount returns a set of the distinct elements of coll.
func SetActivityByAthleteCount(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].AthleteCount]
		if !ok {
			resultMap[list[i].AthleteCount] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByAthleteCountPtr returns a set of the distinct elements of coll.
func SetActivityByAthleteCountPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].AthleteCount]
		if !ok {
			resultMap[list[i].AthleteCount] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByPhotoCount return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByPhotoCount(arrList ...[]Activity) []Activity {
	resultMap := make(map[int]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.PhotoCount]
			if !ok {
				resultMap[v.PhotoCount] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByPhotoCountPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[int]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.PhotoCount]
			if !ok {
				resultMap[v.PhotoCount] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByPhotoCount return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByPhotoCount(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].PhotoCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].PhotoCount] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].PhotoCount == v.PhotoCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].PhotoCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].PhotoCount] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByPhotoCountPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByPhotoCountPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].PhotoCount]
			if !ok {
				resultMap[arrList[0][i].PhotoCount] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].PhotoCount == v.PhotoCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].PhotoCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].PhotoCount] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByPhotoCount returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByPhotoCount(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].PhotoCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].PhotoCount] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].PhotoCount == v.PhotoCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].PhotoCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].PhotoCount] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByPhotoCountPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByPhotoCountPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].PhotoCount]
			if !ok {
				resultMap[arrList[0][i].PhotoCount] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].PhotoCount == v.PhotoCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].PhotoCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].PhotoCount] = true
			}
		}
	}
	return newList
}

// SubsetActivityByPhotoCount returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByPhotoCount(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].PhotoCount]
		if !ok {
			found := false
			resultMap[list1[i].PhotoCount] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].PhotoCount == list2[j].PhotoCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByPhotoCountPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByPhotoCountPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].PhotoCount]
		if !ok {
			found := false
			resultMap[list1[i].PhotoCount] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].PhotoCount == list2[j].PhotoCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByPhotoCount returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByPhotoCount(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].PhotoCount]
		if !ok {
			found := false
			resultMap[list2[i].PhotoCount] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].PhotoCount == list1[j].PhotoCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByPhotoCountPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByPhotoCountPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].PhotoCount]
		if !ok {
			found := false
			resultMap[list2[i].PhotoCount] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].PhotoCount == list1[j].PhotoCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByPhotoCount returns a set of the distinct elements of coll.
func SetActivityByPhotoCount(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].PhotoCount]
		if !ok {
			resultMap[list[i].PhotoCount] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByPhotoCountPtr returns a set of the distinct elements of coll.
func SetActivityByPhotoCountPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].PhotoCount]
		if !ok {
			resultMap[list[i].PhotoCount] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByGearID return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByGearID(arrList ...[]Activity) []Activity {
	resultMap := make(map[string]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.GearID]
			if !ok {
				resultMap[v.GearID] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByGearIDPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[string]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.GearID]
			if !ok {
				resultMap[v.GearID] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByGearID return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByGearID(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].GearID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].GearID] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].GearID == v.GearID {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].GearID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].GearID] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByGearIDPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByGearIDPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].GearID]
			if !ok {
				resultMap[arrList[0][i].GearID] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].GearID == v.GearID {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].GearID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].GearID] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByGearID returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByGearID(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].GearID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].GearID] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].GearID == v.GearID {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].GearID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].GearID] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByGearIDPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByGearIDPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].GearID]
			if !ok {
				resultMap[arrList[0][i].GearID] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].GearID == v.GearID {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].GearID]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].GearID] = true
			}
		}
	}
	return newList
}

// SubsetActivityByGearID returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByGearID(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].GearID]
		if !ok {
			found := false
			resultMap[list1[i].GearID] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].GearID == list2[j].GearID {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByGearIDPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByGearIDPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].GearID]
		if !ok {
			found := false
			resultMap[list1[i].GearID] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].GearID == list2[j].GearID {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByGearID returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByGearID(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].GearID]
		if !ok {
			found := false
			resultMap[list2[i].GearID] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].GearID == list1[j].GearID {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByGearIDPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByGearIDPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].GearID]
		if !ok {
			found := false
			resultMap[list2[i].GearID] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].GearID == list1[j].GearID {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByGearID returns a set of the distinct elements of coll.
func SetActivityByGearID(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].GearID]
		if !ok {
			resultMap[list[i].GearID] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByGearIDPtr returns a set of the distinct elements of coll.
func SetActivityByGearIDPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].GearID]
		if !ok {
			resultMap[list[i].GearID] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByAverageSpeed return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByAverageSpeed(arrList ...[]Activity) []Activity {
	resultMap := make(map[float64]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.AverageSpeed]
			if !ok {
				resultMap[v.AverageSpeed] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByAverageSpeedPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[float64]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.AverageSpeed]
			if !ok {
				resultMap[v.AverageSpeed] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByAverageSpeed return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByAverageSpeed(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AverageSpeed]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageSpeed] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AverageSpeed == v.AverageSpeed {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].AverageSpeed]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageSpeed] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByAverageSpeedPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByAverageSpeedPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AverageSpeed]
			if !ok {
				resultMap[arrList[0][i].AverageSpeed] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AverageSpeed == v.AverageSpeed {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].AverageSpeed]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageSpeed] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByAverageSpeed returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByAverageSpeed(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AverageSpeed]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageSpeed] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AverageSpeed == v.AverageSpeed {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].AverageSpeed]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageSpeed] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByAverageSpeedPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByAverageSpeedPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AverageSpeed]
			if !ok {
				resultMap[arrList[0][i].AverageSpeed] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AverageSpeed == v.AverageSpeed {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].AverageSpeed]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageSpeed] = true
			}
		}
	}
	return newList
}

// SubsetActivityByAverageSpeed returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByAverageSpeed(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].AverageSpeed]
		if !ok {
			found := false
			resultMap[list1[i].AverageSpeed] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].AverageSpeed == list2[j].AverageSpeed {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByAverageSpeedPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByAverageSpeedPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].AverageSpeed]
		if !ok {
			found := false
			resultMap[list1[i].AverageSpeed] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].AverageSpeed == list2[j].AverageSpeed {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByAverageSpeed returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByAverageSpeed(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].AverageSpeed]
		if !ok {
			found := false
			resultMap[list2[i].AverageSpeed] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].AverageSpeed == list1[j].AverageSpeed {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByAverageSpeedPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByAverageSpeedPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].AverageSpeed]
		if !ok {
			found := false
			resultMap[list2[i].AverageSpeed] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].AverageSpeed == list1[j].AverageSpeed {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByAverageSpeed returns a set of the distinct elements of coll.
func SetActivityByAverageSpeed(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].AverageSpeed]
		if !ok {
			resultMap[list[i].AverageSpeed] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByAverageSpeedPtr returns a set of the distinct elements of coll.
func SetActivityByAverageSpeedPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].AverageSpeed]
		if !ok {
			resultMap[list[i].AverageSpeed] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByMaxSpeed return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByMaxSpeed(arrList ...[]Activity) []Activity {
	resultMap := make(map[float64]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.MaxSpeed]
			if !ok {
				resultMap[v.MaxSpeed] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByMaxSpeedPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[float64]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.MaxSpeed]
			if !ok {
				resultMap[v.MaxSpeed] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByMaxSpeed return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByMaxSpeed(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].MaxSpeed]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].MaxSpeed] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].MaxSpeed == v.MaxSpeed {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].MaxSpeed]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].MaxSpeed] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByMaxSpeedPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByMaxSpeedPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].MaxSpeed]
			if !ok {
				resultMap[arrList[0][i].MaxSpeed] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].MaxSpeed == v.MaxSpeed {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].MaxSpeed]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].MaxSpeed] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByMaxSpeed returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByMaxSpeed(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].MaxSpeed]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].MaxSpeed] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].MaxSpeed == v.MaxSpeed {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].MaxSpeed]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].MaxSpeed] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByMaxSpeedPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByMaxSpeedPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].MaxSpeed]
			if !ok {
				resultMap[arrList[0][i].MaxSpeed] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].MaxSpeed == v.MaxSpeed {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].MaxSpeed]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].MaxSpeed] = true
			}
		}
	}
	return newList
}

// SubsetActivityByMaxSpeed returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByMaxSpeed(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].MaxSpeed]
		if !ok {
			found := false
			resultMap[list1[i].MaxSpeed] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].MaxSpeed == list2[j].MaxSpeed {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByMaxSpeedPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByMaxSpeedPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].MaxSpeed]
		if !ok {
			found := false
			resultMap[list1[i].MaxSpeed] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].MaxSpeed == list2[j].MaxSpeed {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByMaxSpeed returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByMaxSpeed(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].MaxSpeed]
		if !ok {
			found := false
			resultMap[list2[i].MaxSpeed] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].MaxSpeed == list1[j].MaxSpeed {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByMaxSpeedPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByMaxSpeedPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].MaxSpeed]
		if !ok {
			found := false
			resultMap[list2[i].MaxSpeed] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].MaxSpeed == list1[j].MaxSpeed {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByMaxSpeed returns a set of the distinct elements of coll.
func SetActivityByMaxSpeed(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].MaxSpeed]
		if !ok {
			resultMap[list[i].MaxSpeed] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByMaxSpeedPtr returns a set of the distinct elements of coll.
func SetActivityByMaxSpeedPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].MaxSpeed]
		if !ok {
			resultMap[list[i].MaxSpeed] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByAverageCadence return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByAverageCadence(arrList ...[]Activity) []Activity {
	resultMap := make(map[float64]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.AverageCadence]
			if !ok {
				resultMap[v.AverageCadence] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByAverageCadencePtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[float64]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.AverageCadence]
			if !ok {
				resultMap[v.AverageCadence] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByAverageCadence return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByAverageCadence(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AverageCadence]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageCadence] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AverageCadence == v.AverageCadence {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].AverageCadence]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageCadence] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByAverageCadencePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByAverageCadencePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AverageCadence]
			if !ok {
				resultMap[arrList[0][i].AverageCadence] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AverageCadence == v.AverageCadence {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].AverageCadence]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageCadence] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByAverageCadence returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByAverageCadence(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AverageCadence]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageCadence] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AverageCadence == v.AverageCadence {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].AverageCadence]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageCadence] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByAverageCadencePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByAverageCadencePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AverageCadence]
			if !ok {
				resultMap[arrList[0][i].AverageCadence] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AverageCadence == v.AverageCadence {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].AverageCadence]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageCadence] = true
			}
		}
	}
	return newList
}

// SubsetActivityByAverageCadence returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByAverageCadence(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].AverageCadence]
		if !ok {
			found := false
			resultMap[list1[i].AverageCadence] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].AverageCadence == list2[j].AverageCadence {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByAverageCadencePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByAverageCadencePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].AverageCadence]
		if !ok {
			found := false
			resultMap[list1[i].AverageCadence] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].AverageCadence == list2[j].AverageCadence {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByAverageCadence returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByAverageCadence(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].AverageCadence]
		if !ok {
			found := false
			resultMap[list2[i].AverageCadence] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].AverageCadence == list1[j].AverageCadence {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByAverageCadencePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByAverageCadencePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].AverageCadence]
		if !ok {
			found := false
			resultMap[list2[i].AverageCadence] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].AverageCadence == list1[j].AverageCadence {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByAverageCadence returns a set of the distinct elements of coll.
func SetActivityByAverageCadence(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].AverageCadence]
		if !ok {
			resultMap[list[i].AverageCadence] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByAverageCadencePtr returns a set of the distinct elements of coll.
func SetActivityByAverageCadencePtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].AverageCadence]
		if !ok {
			resultMap[list[i].AverageCadence] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByAverageTemp return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByAverageTemp(arrList ...[]Activity) []Activity {
	resultMap := make(map[int]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.AverageTemp]
			if !ok {
				resultMap[v.AverageTemp] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByAverageTempPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[int]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.AverageTemp]
			if !ok {
				resultMap[v.AverageTemp] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByAverageTemp return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByAverageTemp(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AverageTemp]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageTemp] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AverageTemp == v.AverageTemp {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].AverageTemp]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageTemp] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByAverageTempPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByAverageTempPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AverageTemp]
			if !ok {
				resultMap[arrList[0][i].AverageTemp] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AverageTemp == v.AverageTemp {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].AverageTemp]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageTemp] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByAverageTemp returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByAverageTemp(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AverageTemp]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageTemp] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AverageTemp == v.AverageTemp {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].AverageTemp]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageTemp] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByAverageTempPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByAverageTempPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AverageTemp]
			if !ok {
				resultMap[arrList[0][i].AverageTemp] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AverageTemp == v.AverageTemp {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].AverageTemp]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageTemp] = true
			}
		}
	}
	return newList
}

// SubsetActivityByAverageTemp returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByAverageTemp(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].AverageTemp]
		if !ok {
			found := false
			resultMap[list1[i].AverageTemp] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].AverageTemp == list2[j].AverageTemp {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByAverageTempPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByAverageTempPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].AverageTemp]
		if !ok {
			found := false
			resultMap[list1[i].AverageTemp] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].AverageTemp == list2[j].AverageTemp {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByAverageTemp returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByAverageTemp(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].AverageTemp]
		if !ok {
			found := false
			resultMap[list2[i].AverageTemp] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].AverageTemp == list1[j].AverageTemp {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByAverageTempPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByAverageTempPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].AverageTemp]
		if !ok {
			found := false
			resultMap[list2[i].AverageTemp] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].AverageTemp == list1[j].AverageTemp {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByAverageTemp returns a set of the distinct elements of coll.
func SetActivityByAverageTemp(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].AverageTemp]
		if !ok {
			resultMap[list[i].AverageTemp] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByAverageTempPtr returns a set of the distinct elements of coll.
func SetActivityByAverageTempPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].AverageTemp]
		if !ok {
			resultMap[list[i].AverageTemp] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByAverageWatts return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByAverageWatts(arrList ...[]Activity) []Activity {
	resultMap := make(map[float64]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.AverageWatts]
			if !ok {
				resultMap[v.AverageWatts] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByAverageWattsPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[float64]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.AverageWatts]
			if !ok {
				resultMap[v.AverageWatts] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByAverageWatts return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByAverageWatts(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AverageWatts]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageWatts] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AverageWatts == v.AverageWatts {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].AverageWatts]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageWatts] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByAverageWattsPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByAverageWattsPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AverageWatts]
			if !ok {
				resultMap[arrList[0][i].AverageWatts] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AverageWatts == v.AverageWatts {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].AverageWatts]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageWatts] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByAverageWatts returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByAverageWatts(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AverageWatts]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageWatts] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AverageWatts == v.AverageWatts {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].AverageWatts]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageWatts] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByAverageWattsPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByAverageWattsPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].AverageWatts]
			if !ok {
				resultMap[arrList[0][i].AverageWatts] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].AverageWatts == v.AverageWatts {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].AverageWatts]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].AverageWatts] = true
			}
		}
	}
	return newList
}

// SubsetActivityByAverageWatts returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByAverageWatts(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].AverageWatts]
		if !ok {
			found := false
			resultMap[list1[i].AverageWatts] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].AverageWatts == list2[j].AverageWatts {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByAverageWattsPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByAverageWattsPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].AverageWatts]
		if !ok {
			found := false
			resultMap[list1[i].AverageWatts] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].AverageWatts == list2[j].AverageWatts {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByAverageWatts returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByAverageWatts(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].AverageWatts]
		if !ok {
			found := false
			resultMap[list2[i].AverageWatts] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].AverageWatts == list1[j].AverageWatts {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByAverageWattsPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByAverageWattsPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].AverageWatts]
		if !ok {
			found := false
			resultMap[list2[i].AverageWatts] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].AverageWatts == list1[j].AverageWatts {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByAverageWatts returns a set of the distinct elements of coll.
func SetActivityByAverageWatts(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].AverageWatts]
		if !ok {
			resultMap[list[i].AverageWatts] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByAverageWattsPtr returns a set of the distinct elements of coll.
func SetActivityByAverageWattsPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].AverageWatts]
		if !ok {
			resultMap[list[i].AverageWatts] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByWeightedAverageWatts return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByWeightedAverageWatts(arrList ...[]Activity) []Activity {
	resultMap := make(map[int]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.WeightedAverageWatts]
			if !ok {
				resultMap[v.WeightedAverageWatts] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByWeightedAverageWattsPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[int]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.WeightedAverageWatts]
			if !ok {
				resultMap[v.WeightedAverageWatts] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByWeightedAverageWatts return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByWeightedAverageWatts(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].WeightedAverageWatts]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].WeightedAverageWatts] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].WeightedAverageWatts == v.WeightedAverageWatts {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].WeightedAverageWatts]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].WeightedAverageWatts] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByWeightedAverageWattsPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByWeightedAverageWattsPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].WeightedAverageWatts]
			if !ok {
				resultMap[arrList[0][i].WeightedAverageWatts] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].WeightedAverageWatts == v.WeightedAverageWatts {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].WeightedAverageWatts]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].WeightedAverageWatts] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByWeightedAverageWatts returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByWeightedAverageWatts(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].WeightedAverageWatts]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].WeightedAverageWatts] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].WeightedAverageWatts == v.WeightedAverageWatts {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].WeightedAverageWatts]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].WeightedAverageWatts] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByWeightedAverageWattsPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByWeightedAverageWattsPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].WeightedAverageWatts]
			if !ok {
				resultMap[arrList[0][i].WeightedAverageWatts] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].WeightedAverageWatts == v.WeightedAverageWatts {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].WeightedAverageWatts]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].WeightedAverageWatts] = true
			}
		}
	}
	return newList
}

// SubsetActivityByWeightedAverageWatts returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByWeightedAverageWatts(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].WeightedAverageWatts]
		if !ok {
			found := false
			resultMap[list1[i].WeightedAverageWatts] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].WeightedAverageWatts == list2[j].WeightedAverageWatts {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByWeightedAverageWattsPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByWeightedAverageWattsPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].WeightedAverageWatts]
		if !ok {
			found := false
			resultMap[list1[i].WeightedAverageWatts] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].WeightedAverageWatts == list2[j].WeightedAverageWatts {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByWeightedAverageWatts returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByWeightedAverageWatts(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].WeightedAverageWatts]
		if !ok {
			found := false
			resultMap[list2[i].WeightedAverageWatts] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].WeightedAverageWatts == list1[j].WeightedAverageWatts {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByWeightedAverageWattsPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByWeightedAverageWattsPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].WeightedAverageWatts]
		if !ok {
			found := false
			resultMap[list2[i].WeightedAverageWatts] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].WeightedAverageWatts == list1[j].WeightedAverageWatts {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByWeightedAverageWatts returns a set of the distinct elements of coll.
func SetActivityByWeightedAverageWatts(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].WeightedAverageWatts]
		if !ok {
			resultMap[list[i].WeightedAverageWatts] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByWeightedAverageWattsPtr returns a set of the distinct elements of coll.
func SetActivityByWeightedAverageWattsPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].WeightedAverageWatts]
		if !ok {
			resultMap[list[i].WeightedAverageWatts] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByKilojoules return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByKilojoules(arrList ...[]Activity) []Activity {
	resultMap := make(map[float64]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Kilojoules]
			if !ok {
				resultMap[v.Kilojoules] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByKilojoulesPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[float64]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Kilojoules]
			if !ok {
				resultMap[v.Kilojoules] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByKilojoules return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByKilojoules(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Kilojoules]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Kilojoules] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Kilojoules == v.Kilojoules {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Kilojoules]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Kilojoules] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByKilojoulesPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByKilojoulesPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Kilojoules]
			if !ok {
				resultMap[arrList[0][i].Kilojoules] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Kilojoules == v.Kilojoules {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Kilojoules]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Kilojoules] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByKilojoules returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByKilojoules(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Kilojoules]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Kilojoules] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Kilojoules == v.Kilojoules {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Kilojoules]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Kilojoules] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByKilojoulesPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByKilojoulesPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Kilojoules]
			if !ok {
				resultMap[arrList[0][i].Kilojoules] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Kilojoules == v.Kilojoules {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Kilojoules]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Kilojoules] = true
			}
		}
	}
	return newList
}

// SubsetActivityByKilojoules returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByKilojoules(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Kilojoules]
		if !ok {
			found := false
			resultMap[list1[i].Kilojoules] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Kilojoules == list2[j].Kilojoules {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByKilojoulesPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByKilojoulesPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Kilojoules]
		if !ok {
			found := false
			resultMap[list1[i].Kilojoules] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Kilojoules == list2[j].Kilojoules {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByKilojoules returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByKilojoules(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Kilojoules]
		if !ok {
			found := false
			resultMap[list2[i].Kilojoules] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Kilojoules == list1[j].Kilojoules {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByKilojoulesPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByKilojoulesPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Kilojoules]
		if !ok {
			found := false
			resultMap[list2[i].Kilojoules] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Kilojoules == list1[j].Kilojoules {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByKilojoules returns a set of the distinct elements of coll.
func SetActivityByKilojoules(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Kilojoules]
		if !ok {
			resultMap[list[i].Kilojoules] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByKilojoulesPtr returns a set of the distinct elements of coll.
func SetActivityByKilojoulesPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Kilojoules]
		if !ok {
			resultMap[list[i].Kilojoules] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByMaxWatts return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByMaxWatts(arrList ...[]Activity) []Activity {
	resultMap := make(map[int]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.MaxWatts]
			if !ok {
				resultMap[v.MaxWatts] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByMaxWattsPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[int]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.MaxWatts]
			if !ok {
				resultMap[v.MaxWatts] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByMaxWatts return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByMaxWatts(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].MaxWatts]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].MaxWatts] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].MaxWatts == v.MaxWatts {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].MaxWatts]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].MaxWatts] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByMaxWattsPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByMaxWattsPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].MaxWatts]
			if !ok {
				resultMap[arrList[0][i].MaxWatts] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].MaxWatts == v.MaxWatts {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].MaxWatts]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].MaxWatts] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByMaxWatts returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByMaxWatts(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].MaxWatts]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].MaxWatts] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].MaxWatts == v.MaxWatts {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].MaxWatts]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].MaxWatts] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByMaxWattsPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByMaxWattsPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].MaxWatts]
			if !ok {
				resultMap[arrList[0][i].MaxWatts] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].MaxWatts == v.MaxWatts {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].MaxWatts]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].MaxWatts] = true
			}
		}
	}
	return newList
}

// SubsetActivityByMaxWatts returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByMaxWatts(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].MaxWatts]
		if !ok {
			found := false
			resultMap[list1[i].MaxWatts] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].MaxWatts == list2[j].MaxWatts {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByMaxWattsPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByMaxWattsPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].MaxWatts]
		if !ok {
			found := false
			resultMap[list1[i].MaxWatts] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].MaxWatts == list2[j].MaxWatts {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByMaxWatts returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByMaxWatts(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].MaxWatts]
		if !ok {
			found := false
			resultMap[list2[i].MaxWatts] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].MaxWatts == list1[j].MaxWatts {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByMaxWattsPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByMaxWattsPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].MaxWatts]
		if !ok {
			found := false
			resultMap[list2[i].MaxWatts] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].MaxWatts == list1[j].MaxWatts {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByMaxWatts returns a set of the distinct elements of coll.
func SetActivityByMaxWatts(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].MaxWatts]
		if !ok {
			resultMap[list[i].MaxWatts] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByMaxWattsPtr returns a set of the distinct elements of coll.
func SetActivityByMaxWattsPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].MaxWatts]
		if !ok {
			resultMap[list[i].MaxWatts] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByElevationHigh return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByElevationHigh(arrList ...[]Activity) []Activity {
	resultMap := make(map[float64]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.ElevationHigh]
			if !ok {
				resultMap[v.ElevationHigh] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByElevationHighPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[float64]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.ElevationHigh]
			if !ok {
				resultMap[v.ElevationHigh] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByElevationHigh return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByElevationHigh(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ElevationHigh]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ElevationHigh] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ElevationHigh == v.ElevationHigh {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].ElevationHigh]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ElevationHigh] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByElevationHighPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByElevationHighPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ElevationHigh]
			if !ok {
				resultMap[arrList[0][i].ElevationHigh] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ElevationHigh == v.ElevationHigh {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].ElevationHigh]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ElevationHigh] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByElevationHigh returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByElevationHigh(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ElevationHigh]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ElevationHigh] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ElevationHigh == v.ElevationHigh {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].ElevationHigh]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ElevationHigh] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByElevationHighPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByElevationHighPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ElevationHigh]
			if !ok {
				resultMap[arrList[0][i].ElevationHigh] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ElevationHigh == v.ElevationHigh {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].ElevationHigh]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ElevationHigh] = true
			}
		}
	}
	return newList
}

// SubsetActivityByElevationHigh returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByElevationHigh(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].ElevationHigh]
		if !ok {
			found := false
			resultMap[list1[i].ElevationHigh] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].ElevationHigh == list2[j].ElevationHigh {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByElevationHighPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByElevationHighPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].ElevationHigh]
		if !ok {
			found := false
			resultMap[list1[i].ElevationHigh] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].ElevationHigh == list2[j].ElevationHigh {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByElevationHigh returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByElevationHigh(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].ElevationHigh]
		if !ok {
			found := false
			resultMap[list2[i].ElevationHigh] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].ElevationHigh == list1[j].ElevationHigh {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByElevationHighPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByElevationHighPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].ElevationHigh]
		if !ok {
			found := false
			resultMap[list2[i].ElevationHigh] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].ElevationHigh == list1[j].ElevationHigh {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByElevationHigh returns a set of the distinct elements of coll.
func SetActivityByElevationHigh(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].ElevationHigh]
		if !ok {
			resultMap[list[i].ElevationHigh] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByElevationHighPtr returns a set of the distinct elements of coll.
func SetActivityByElevationHighPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].ElevationHigh]
		if !ok {
			resultMap[list[i].ElevationHigh] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByElevationLow return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByElevationLow(arrList ...[]Activity) []Activity {
	resultMap := make(map[float64]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.ElevationLow]
			if !ok {
				resultMap[v.ElevationLow] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByElevationLowPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[float64]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.ElevationLow]
			if !ok {
				resultMap[v.ElevationLow] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByElevationLow return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByElevationLow(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ElevationLow]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ElevationLow] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ElevationLow == v.ElevationLow {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].ElevationLow]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ElevationLow] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByElevationLowPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByElevationLowPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ElevationLow]
			if !ok {
				resultMap[arrList[0][i].ElevationLow] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ElevationLow == v.ElevationLow {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].ElevationLow]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ElevationLow] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByElevationLow returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByElevationLow(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ElevationLow]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ElevationLow] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ElevationLow == v.ElevationLow {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].ElevationLow]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ElevationLow] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByElevationLowPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByElevationLowPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].ElevationLow]
			if !ok {
				resultMap[arrList[0][i].ElevationLow] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].ElevationLow == v.ElevationLow {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].ElevationLow]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].ElevationLow] = true
			}
		}
	}
	return newList
}

// SubsetActivityByElevationLow returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByElevationLow(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].ElevationLow]
		if !ok {
			found := false
			resultMap[list1[i].ElevationLow] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].ElevationLow == list2[j].ElevationLow {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByElevationLowPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByElevationLowPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].ElevationLow]
		if !ok {
			found := false
			resultMap[list1[i].ElevationLow] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].ElevationLow == list2[j].ElevationLow {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByElevationLow returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByElevationLow(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].ElevationLow]
		if !ok {
			found := false
			resultMap[list2[i].ElevationLow] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].ElevationLow == list1[j].ElevationLow {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByElevationLowPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByElevationLowPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].ElevationLow]
		if !ok {
			found := false
			resultMap[list2[i].ElevationLow] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].ElevationLow == list1[j].ElevationLow {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByElevationLow returns a set of the distinct elements of coll.
func SetActivityByElevationLow(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].ElevationLow]
		if !ok {
			resultMap[list[i].ElevationLow] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByElevationLowPtr returns a set of the distinct elements of coll.
func SetActivityByElevationLowPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].ElevationLow]
		if !ok {
			resultMap[list[i].ElevationLow] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByPrCount return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByPrCount(arrList ...[]Activity) []Activity {
	resultMap := make(map[int]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.PrCount]
			if !ok {
				resultMap[v.PrCount] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByPrCountPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[int]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.PrCount]
			if !ok {
				resultMap[v.PrCount] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByPrCount return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByPrCount(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].PrCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].PrCount] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].PrCount == v.PrCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].PrCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].PrCount] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByPrCountPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByPrCountPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].PrCount]
			if !ok {
				resultMap[arrList[0][i].PrCount] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].PrCount == v.PrCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].PrCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].PrCount] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByPrCount returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByPrCount(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].PrCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].PrCount] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].PrCount == v.PrCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].PrCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].PrCount] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByPrCountPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByPrCountPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].PrCount]
			if !ok {
				resultMap[arrList[0][i].PrCount] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].PrCount == v.PrCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].PrCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].PrCount] = true
			}
		}
	}
	return newList
}

// SubsetActivityByPrCount returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByPrCount(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].PrCount]
		if !ok {
			found := false
			resultMap[list1[i].PrCount] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].PrCount == list2[j].PrCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByPrCountPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByPrCountPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].PrCount]
		if !ok {
			found := false
			resultMap[list1[i].PrCount] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].PrCount == list2[j].PrCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByPrCount returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByPrCount(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].PrCount]
		if !ok {
			found := false
			resultMap[list2[i].PrCount] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].PrCount == list1[j].PrCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByPrCountPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByPrCountPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].PrCount]
		if !ok {
			found := false
			resultMap[list2[i].PrCount] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].PrCount == list1[j].PrCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByPrCount returns a set of the distinct elements of coll.
func SetActivityByPrCount(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].PrCount]
		if !ok {
			resultMap[list[i].PrCount] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByPrCountPtr returns a set of the distinct elements of coll.
func SetActivityByPrCountPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].PrCount]
		if !ok {
			resultMap[list[i].PrCount] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByTotalPhotoCount return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByTotalPhotoCount(arrList ...[]Activity) []Activity {
	resultMap := make(map[int]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.TotalPhotoCount]
			if !ok {
				resultMap[v.TotalPhotoCount] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByTotalPhotoCountPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[int]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.TotalPhotoCount]
			if !ok {
				resultMap[v.TotalPhotoCount] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByTotalPhotoCount return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByTotalPhotoCount(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].TotalPhotoCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].TotalPhotoCount] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].TotalPhotoCount == v.TotalPhotoCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].TotalPhotoCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].TotalPhotoCount] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByTotalPhotoCountPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByTotalPhotoCountPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].TotalPhotoCount]
			if !ok {
				resultMap[arrList[0][i].TotalPhotoCount] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].TotalPhotoCount == v.TotalPhotoCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].TotalPhotoCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].TotalPhotoCount] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByTotalPhotoCount returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByTotalPhotoCount(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].TotalPhotoCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].TotalPhotoCount] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].TotalPhotoCount == v.TotalPhotoCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].TotalPhotoCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].TotalPhotoCount] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByTotalPhotoCountPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByTotalPhotoCountPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].TotalPhotoCount]
			if !ok {
				resultMap[arrList[0][i].TotalPhotoCount] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].TotalPhotoCount == v.TotalPhotoCount {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].TotalPhotoCount]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].TotalPhotoCount] = true
			}
		}
	}
	return newList
}

// SubsetActivityByTotalPhotoCount returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByTotalPhotoCount(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].TotalPhotoCount]
		if !ok {
			found := false
			resultMap[list1[i].TotalPhotoCount] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].TotalPhotoCount == list2[j].TotalPhotoCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByTotalPhotoCountPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByTotalPhotoCountPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].TotalPhotoCount]
		if !ok {
			found := false
			resultMap[list1[i].TotalPhotoCount] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].TotalPhotoCount == list2[j].TotalPhotoCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByTotalPhotoCount returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByTotalPhotoCount(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].TotalPhotoCount]
		if !ok {
			found := false
			resultMap[list2[i].TotalPhotoCount] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].TotalPhotoCount == list1[j].TotalPhotoCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByTotalPhotoCountPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByTotalPhotoCountPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].TotalPhotoCount]
		if !ok {
			found := false
			resultMap[list2[i].TotalPhotoCount] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].TotalPhotoCount == list1[j].TotalPhotoCount {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByTotalPhotoCount returns a set of the distinct elements of coll.
func SetActivityByTotalPhotoCount(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].TotalPhotoCount]
		if !ok {
			resultMap[list[i].TotalPhotoCount] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByTotalPhotoCountPtr returns a set of the distinct elements of coll.
func SetActivityByTotalPhotoCountPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].TotalPhotoCount]
		if !ok {
			resultMap[list[i].TotalPhotoCount] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByWorkoutType return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByWorkoutType(arrList ...[]Activity) []Activity {
	resultMap := make(map[int]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.WorkoutType]
			if !ok {
				resultMap[v.WorkoutType] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByWorkoutTypePtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[int]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.WorkoutType]
			if !ok {
				resultMap[v.WorkoutType] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByWorkoutType return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByWorkoutType(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].WorkoutType]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].WorkoutType] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].WorkoutType == v.WorkoutType {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].WorkoutType]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].WorkoutType] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByWorkoutTypePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByWorkoutTypePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].WorkoutType]
			if !ok {
				resultMap[arrList[0][i].WorkoutType] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].WorkoutType == v.WorkoutType {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].WorkoutType]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].WorkoutType] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByWorkoutType returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByWorkoutType(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].WorkoutType]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].WorkoutType] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].WorkoutType == v.WorkoutType {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].WorkoutType]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].WorkoutType] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByWorkoutTypePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByWorkoutTypePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].WorkoutType]
			if !ok {
				resultMap[arrList[0][i].WorkoutType] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].WorkoutType == v.WorkoutType {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].WorkoutType]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].WorkoutType] = true
			}
		}
	}
	return newList
}

// SubsetActivityByWorkoutType returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByWorkoutType(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].WorkoutType]
		if !ok {
			found := false
			resultMap[list1[i].WorkoutType] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].WorkoutType == list2[j].WorkoutType {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByWorkoutTypePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByWorkoutTypePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].WorkoutType]
		if !ok {
			found := false
			resultMap[list1[i].WorkoutType] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].WorkoutType == list2[j].WorkoutType {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByWorkoutType returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByWorkoutType(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].WorkoutType]
		if !ok {
			found := false
			resultMap[list2[i].WorkoutType] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].WorkoutType == list1[j].WorkoutType {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByWorkoutTypePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByWorkoutTypePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[int]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].WorkoutType]
		if !ok {
			found := false
			resultMap[list2[i].WorkoutType] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].WorkoutType == list1[j].WorkoutType {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByWorkoutType returns a set of the distinct elements of coll.
func SetActivityByWorkoutType(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].WorkoutType]
		if !ok {
			resultMap[list[i].WorkoutType] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByWorkoutTypePtr returns a set of the distinct elements of coll.
func SetActivityByWorkoutTypePtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[int]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].WorkoutType]
		if !ok {
			resultMap[list[i].WorkoutType] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityBySufferScore return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityBySufferScore(arrList ...[]Activity) []Activity {
	resultMap := make(map[float64]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.SufferScore]
			if !ok {
				resultMap[v.SufferScore] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityBySufferScorePtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[float64]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.SufferScore]
			if !ok {
				resultMap[v.SufferScore] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityBySufferScore return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityBySufferScore(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].SufferScore]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].SufferScore] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].SufferScore == v.SufferScore {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].SufferScore]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].SufferScore] = true
			}
		}
	}
	return newList
}

// IntersectionActivityBySufferScorePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityBySufferScorePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].SufferScore]
			if !ok {
				resultMap[arrList[0][i].SufferScore] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].SufferScore == v.SufferScore {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].SufferScore]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].SufferScore] = true
			}
		}
	}
	return newList
}

// DifferenceActivityBySufferScore returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityBySufferScore(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].SufferScore]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].SufferScore] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].SufferScore == v.SufferScore {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].SufferScore]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].SufferScore] = true
			}
		}
	}
	return newList
}

// DifferenceActivityBySufferScorePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityBySufferScorePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].SufferScore]
			if !ok {
				resultMap[arrList[0][i].SufferScore] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].SufferScore == v.SufferScore {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].SufferScore]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].SufferScore] = true
			}
		}
	}
	return newList
}

// SubsetActivityBySufferScore returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityBySufferScore(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].SufferScore]
		if !ok {
			found := false
			resultMap[list1[i].SufferScore] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].SufferScore == list2[j].SufferScore {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityBySufferScorePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityBySufferScorePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].SufferScore]
		if !ok {
			found := false
			resultMap[list1[i].SufferScore] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].SufferScore == list2[j].SufferScore {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityBySufferScore returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityBySufferScore(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].SufferScore]
		if !ok {
			found := false
			resultMap[list2[i].SufferScore] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].SufferScore == list1[j].SufferScore {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityBySufferScorePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityBySufferScorePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].SufferScore]
		if !ok {
			found := false
			resultMap[list2[i].SufferScore] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].SufferScore == list1[j].SufferScore {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityBySufferScore returns a set of the distinct elements of coll.
func SetActivityBySufferScore(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].SufferScore]
		if !ok {
			resultMap[list[i].SufferScore] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityBySufferScorePtr returns a set of the distinct elements of coll.
func SetActivityBySufferScorePtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].SufferScore]
		if !ok {
			resultMap[list[i].SufferScore] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByDescription return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByDescription(arrList ...[]Activity) []Activity {
	resultMap := make(map[string]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Description]
			if !ok {
				resultMap[v.Description] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByDescriptionPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[string]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Description]
			if !ok {
				resultMap[v.Description] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByDescription return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByDescription(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Description]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Description] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Description == v.Description {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Description]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Description] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByDescriptionPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByDescriptionPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Description]
			if !ok {
				resultMap[arrList[0][i].Description] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Description == v.Description {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Description]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Description] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByDescription returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByDescription(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Description]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Description] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Description == v.Description {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Description]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Description] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByDescriptionPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByDescriptionPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Description]
			if !ok {
				resultMap[arrList[0][i].Description] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Description == v.Description {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Description]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Description] = true
			}
		}
	}
	return newList
}

// SubsetActivityByDescription returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByDescription(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Description]
		if !ok {
			found := false
			resultMap[list1[i].Description] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Description == list2[j].Description {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByDescriptionPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByDescriptionPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Description]
		if !ok {
			found := false
			resultMap[list1[i].Description] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Description == list2[j].Description {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByDescription returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByDescription(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Description]
		if !ok {
			found := false
			resultMap[list2[i].Description] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Description == list1[j].Description {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByDescriptionPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByDescriptionPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Description]
		if !ok {
			found := false
			resultMap[list2[i].Description] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Description == list1[j].Description {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByDescription returns a set of the distinct elements of coll.
func SetActivityByDescription(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Description]
		if !ok {
			resultMap[list[i].Description] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByDescriptionPtr returns a set of the distinct elements of coll.
func SetActivityByDescriptionPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Description]
		if !ok {
			resultMap[list[i].Description] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByCalories return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByCalories(arrList ...[]Activity) []Activity {
	resultMap := make(map[float64]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Calories]
			if !ok {
				resultMap[v.Calories] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByCaloriesPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[float64]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.Calories]
			if !ok {
				resultMap[v.Calories] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByCalories return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByCalories(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Calories]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Calories] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Calories == v.Calories {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Calories]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Calories] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByCaloriesPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByCaloriesPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Calories]
			if !ok {
				resultMap[arrList[0][i].Calories] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Calories == v.Calories {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].Calories]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Calories] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByCalories returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByCalories(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Calories]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Calories] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Calories == v.Calories {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Calories]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Calories] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByCaloriesPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByCaloriesPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].Calories]
			if !ok {
				resultMap[arrList[0][i].Calories] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].Calories == v.Calories {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].Calories]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].Calories] = true
			}
		}
	}
	return newList
}

// SubsetActivityByCalories returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByCalories(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Calories]
		if !ok {
			found := false
			resultMap[list1[i].Calories] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Calories == list2[j].Calories {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByCaloriesPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByCaloriesPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].Calories]
		if !ok {
			found := false
			resultMap[list1[i].Calories] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].Calories == list2[j].Calories {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByCalories returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByCalories(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Calories]
		if !ok {
			found := false
			resultMap[list2[i].Calories] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Calories == list1[j].Calories {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByCaloriesPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByCaloriesPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].Calories]
		if !ok {
			found := false
			resultMap[list2[i].Calories] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].Calories == list1[j].Calories {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByCalories returns a set of the distinct elements of coll.
func SetActivityByCalories(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Calories]
		if !ok {
			resultMap[list[i].Calories] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByCaloriesPtr returns a set of the distinct elements of coll.
func SetActivityByCaloriesPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].Calories]
		if !ok {
			resultMap[list[i].Calories] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByDeviceName return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByDeviceName(arrList ...[]Activity) []Activity {
	resultMap := make(map[string]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.DeviceName]
			if !ok {
				resultMap[v.DeviceName] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByDeviceNamePtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[string]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.DeviceName]
			if !ok {
				resultMap[v.DeviceName] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByDeviceName return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByDeviceName(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].DeviceName]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].DeviceName] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].DeviceName == v.DeviceName {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].DeviceName]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].DeviceName] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByDeviceNamePtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByDeviceNamePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].DeviceName]
			if !ok {
				resultMap[arrList[0][i].DeviceName] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].DeviceName == v.DeviceName {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].DeviceName]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].DeviceName] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByDeviceName returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByDeviceName(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].DeviceName]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].DeviceName] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].DeviceName == v.DeviceName {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].DeviceName]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].DeviceName] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByDeviceNamePtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByDeviceNamePtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].DeviceName]
			if !ok {
				resultMap[arrList[0][i].DeviceName] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].DeviceName == v.DeviceName {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].DeviceName]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].DeviceName] = true
			}
		}
	}
	return newList
}

// SubsetActivityByDeviceName returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByDeviceName(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].DeviceName]
		if !ok {
			found := false
			resultMap[list1[i].DeviceName] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].DeviceName == list2[j].DeviceName {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByDeviceNamePtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByDeviceNamePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].DeviceName]
		if !ok {
			found := false
			resultMap[list1[i].DeviceName] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].DeviceName == list2[j].DeviceName {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByDeviceName returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByDeviceName(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].DeviceName]
		if !ok {
			found := false
			resultMap[list2[i].DeviceName] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].DeviceName == list1[j].DeviceName {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByDeviceNamePtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByDeviceNamePtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].DeviceName]
		if !ok {
			found := false
			resultMap[list2[i].DeviceName] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].DeviceName == list1[j].DeviceName {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByDeviceName returns a set of the distinct elements of coll.
func SetActivityByDeviceName(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].DeviceName]
		if !ok {
			resultMap[list[i].DeviceName] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByDeviceNamePtr returns a set of the distinct elements of coll.
func SetActivityByDeviceNamePtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].DeviceName]
		if !ok {
			resultMap[list[i].DeviceName] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByEmbedToken return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByEmbedToken(arrList ...[]Activity) []Activity {
	resultMap := make(map[string]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.EmbedToken]
			if !ok {
				resultMap[v.EmbedToken] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByEmbedTokenPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[string]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.EmbedToken]
			if !ok {
				resultMap[v.EmbedToken] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByEmbedToken return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByEmbedToken(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].EmbedToken]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].EmbedToken] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].EmbedToken == v.EmbedToken {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].EmbedToken]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].EmbedToken] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByEmbedTokenPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByEmbedTokenPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].EmbedToken]
			if !ok {
				resultMap[arrList[0][i].EmbedToken] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].EmbedToken == v.EmbedToken {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].EmbedToken]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].EmbedToken] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByEmbedToken returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByEmbedToken(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].EmbedToken]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].EmbedToken] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].EmbedToken == v.EmbedToken {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].EmbedToken]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].EmbedToken] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByEmbedTokenPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByEmbedTokenPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].EmbedToken]
			if !ok {
				resultMap[arrList[0][i].EmbedToken] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].EmbedToken == v.EmbedToken {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].EmbedToken]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].EmbedToken] = true
			}
		}
	}
	return newList
}

// SubsetActivityByEmbedToken returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByEmbedToken(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].EmbedToken]
		if !ok {
			found := false
			resultMap[list1[i].EmbedToken] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].EmbedToken == list2[j].EmbedToken {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByEmbedTokenPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByEmbedTokenPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].EmbedToken]
		if !ok {
			found := false
			resultMap[list1[i].EmbedToken] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].EmbedToken == list2[j].EmbedToken {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByEmbedToken returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByEmbedToken(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].EmbedToken]
		if !ok {
			found := false
			resultMap[list2[i].EmbedToken] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].EmbedToken == list1[j].EmbedToken {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByEmbedTokenPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByEmbedTokenPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[string]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].EmbedToken]
		if !ok {
			found := false
			resultMap[list2[i].EmbedToken] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].EmbedToken == list1[j].EmbedToken {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByEmbedToken returns a set of the distinct elements of coll.
func SetActivityByEmbedToken(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[string]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].EmbedToken]
		if !ok {
			resultMap[list[i].EmbedToken] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByEmbedTokenPtr returns a set of the distinct elements of coll.
func SetActivityByEmbedTokenPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[string]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].EmbedToken]
		if !ok {
			resultMap[list[i].EmbedToken] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
// UnionActivityByPerceivedExertion return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByPerceivedExertion(arrList ...[]Activity) []Activity {
	resultMap := make(map[float64]bool)
	var resultArr []Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.PerceivedExertion]
			if !ok {
				resultMap[v.PerceivedExertion] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Union<FTYPE>Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionActivityByPerceivedExertionPtr(arrList ...[]*Activity) []*Activity {
	resultMap := make(map[float64]bool)
	var resultArr []*Activity
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[v.PerceivedExertion]
			if !ok {
				resultMap[v.PerceivedExertion] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// IntersectionActivityByPerceivedExertion return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByPerceivedExertion(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].PerceivedExertion]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].PerceivedExertion] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].PerceivedExertion == v.PerceivedExertion {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].PerceivedExertion]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].PerceivedExertion] = true
			}
		}
	}
	return newList
}

// IntersectionActivityByPerceivedExertionPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionActivityByPerceivedExertionPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].PerceivedExertion]
			if !ok {
				resultMap[arrList[0][i].PerceivedExertion] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].PerceivedExertion == v.PerceivedExertion {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i].PerceivedExertion]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].PerceivedExertion] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByPerceivedExertion returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByPerceivedExertion(arrList ...[]Activity) []Activity {
	if arrList == nil {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].PerceivedExertion]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].PerceivedExertion] = true
			}
		}
		return newList
	}

	var newList []Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].PerceivedExertion == v.PerceivedExertion {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].PerceivedExertion]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].PerceivedExertion] = true
			}
		}
	}
	return newList
}

// DifferenceActivityByPerceivedExertionPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceActivityByPerceivedExertionPtr(arrList ...[]*Activity) []*Activity {
	if arrList == nil {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	if len(arrList) == 1 {
		var newList []*Activity
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i].PerceivedExertion]
			if !ok {
				resultMap[arrList[0][i].PerceivedExertion] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*Activity
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i].PerceivedExertion == v.PerceivedExertion {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i].PerceivedExertion]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i].PerceivedExertion] = true
			}
		}
	}
	return newList
}

// SubsetActivityByPerceivedExertion returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByPerceivedExertion(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].PerceivedExertion]
		if !ok {
			found := false
			resultMap[list1[i].PerceivedExertion] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].PerceivedExertion == list2[j].PerceivedExertion {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SubsetActivityByPerceivedExertionPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func SubsetActivityByPerceivedExertionPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i].PerceivedExertion]
		if !ok {
			found := false
			resultMap[list1[i].PerceivedExertion] = true
			for j := 0; j < len(list2); j++ {
				if list1[i].PerceivedExertion == list2[j].PerceivedExertion {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByPerceivedExertion returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByPerceivedExertion(list1, list2 []Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].PerceivedExertion]
		if !ok {
			found := false
			resultMap[list2[i].PerceivedExertion] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].PerceivedExertion == list1[j].PerceivedExertion {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SupersetActivityByPerceivedExertionPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func SupersetActivityByPerceivedExertionPtr(list1, list2 []*Activity) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[float64]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i].PerceivedExertion]
		if !ok {
			found := false
			resultMap[list2[i].PerceivedExertion] = true
			for j := 0; j < len(list1); j++ {
				if list2[i].PerceivedExertion == list1[j].PerceivedExertion {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// SetActivityByPerceivedExertion returns a set of the distinct elements of coll.
func SetActivityByPerceivedExertion(list []Activity) []Activity {
	if list == nil || len(list) == 0 {
		return []Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].PerceivedExertion]
		if !ok {
			resultMap[list[i].PerceivedExertion] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetActivityByPerceivedExertionPtr returns a set of the distinct elements of coll.
func SetActivityByPerceivedExertionPtr(list []*Activity) []*Activity {
	if list == nil || len(list) == 0 {
		return []*Activity{}
	}

	resultMap := make(map[float64]bool)
	newList := []*Activity{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i].PerceivedExertion]
		if !ok {
			resultMap[list[i].PerceivedExertion] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}