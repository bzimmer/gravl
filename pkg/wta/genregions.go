// +build ignore

package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"io/ioutil"
	"net/http"
	"os"
	"regexp"
	"sort"
	"strings"
	"time"

	"github.com/bzimmer/httpwares"
	"github.com/gocolly/colly/v2"
	"github.com/rs/zerolog/log"
)

const (
	local   = true
	baseURL = "https://www.wta.org/go-outside/trip-reports"
)

type Region struct {
	ID         string
	Name       string
	SubRegions []Region
}

type RegionScraper struct {
	Regions    []Region
	SubRegions map[string]map[string]string
}

func (r *RegionScraper) SuperRegion(e *colly.HTMLElement) {
	e.ForEach("option", func(index int, elem *colly.HTMLElement) {
		if index == 0 {
			return
		}
		r.Regions = append(r.Regions, Region{
			ID:   strings.TrimSpace(elem.Attr("value")),
			Name: strings.TrimSpace(elem.Text),
		})
	})
}

func (r *RegionScraper) SubRegion(e *colly.HTMLElement) {
	x := regexp.MustCompile(`var subregion_options\s+=\s+(?P<SubRegion>.*);`)
	if m := x.FindStringSubmatch(e.Text); m != nil {
		b := strings.ReplaceAll(m[1], "\\", "")
		err := json.Unmarshal([]byte(b), &r.SubRegions)
		if err != nil {
			log.Error().Err(err).Msg("failed to unmarshal subregions")
			return
		}
	}
}

func (r *RegionScraper) ToSource() ([]byte, error) {
	regions := make([]Region, 0)
	for _, region := range r.Regions {
		id := region.ID
		if subs, ok := r.SubRegions[id]; ok {
			for key, value := range subs {
				r := Region{ID: key, Name: value}
				region.SubRegions = append(region.SubRegions, r)
			}
		}
		regions = append(regions, region)
	}

	// Format:
	// var regions = []*Region{
	// 	&Region{ID: "b4845d8a21ad6a202944425c86b6e85f", Name: "Central Cascades",
	// 		SubRegions: []*Region{
	// 			&Region{ID: "83c2ab06fbf236015c8848042f706d58", Name: "Blewett Pass"},
	// 			&Region{ID: "2b0ca41464d9baca77ced16fb4d40760", Name: "Entiat Mountains/Lake Chelan"},
	// 			&Region{ID: "684278bc46c11ebe3c5b7212b6f8e486", Name: "Leavenworth Area"},
	// 			&Region{ID: "f6845d37f1edba9dc2bc8a75346f5bd5", Name: "Stevens Pass - East"},
	// 			&Region{ID: "637634387ca38685f89162475c7fc1d2", Name: "Stevens Pass - West"},
	// 		}}}

	w := new(bytes.Buffer)
	fmt.Fprintln(w, "// Code generated by \"genregions.go\"; DO NOT EDIT.")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "package wta")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "// regions of WTA trip reports")
	fmt.Fprintln(w, "var regions = []*Region{")
	sort.SliceStable(regions, func(i, j int) bool {
		return regions[i].Name < regions[j].Name
	})
	for _, region := range regions {
		fmt.Fprintf(w, "&Region{ID:\"%s\", Name: \"%s\",\n", region.ID, region.Name)
		fmt.Fprintf(w, "SubRegions: []*Region{\n")
		sort.SliceStable(region.SubRegions, func(i, j int) bool {
			return region.SubRegions[i].Name < region.SubRegions[j].Name
		})
		for _, subregion := range region.SubRegions {
			fmt.Fprintf(w, "&Region{ID: \"%s\", Name: \"%s\"},\n", subregion.ID, subregion.Name)
		}
		fmt.Fprintln(w, "},")
		fmt.Fprintln(w, "},")
	}
	fmt.Fprintln(w, "}")
	return format.Source(w.Bytes())
}

func run() error {
	collector := colly.NewCollector(
		colly.AllowedDomains("wta.org", "www.wta.org"))

	if local {
		// read from static html for testing purposes
		collector.WithTransport(&httpwares.TestDataTransport{
			Status:      http.StatusOK,
			Filename:    "wta_regions.html",
			ContentType: "text/html; charset=utf-8",
		})
	}

	log.Info().Bool("local mode", local).Msg("genregions")

	r := &RegionScraper{}
	collector.OnHTML("script", r.SubRegion)
	collector.OnHTML("select[id=super-region]", r.SuperRegion)

	defer func(start time.Time) {
		log.Info().
			Str("url", baseURL).
			Str("op", "regions").
			Dur("elapsed", time.Since(start)).
			Msg("genregions")
	}(time.Now())

	err := collector.Visit(baseURL)
	if err != nil {
		return err
	}

	var src []byte
	if src, err = r.ToSource(); err == nil {
		if err = ioutil.WriteFile("regions_regions.go", src, 0644); err != nil {
			return err
		}
		return nil
	}
	return err
}

func main() {
	if err := run(); err != nil {
		log.Error().Err(err).Bool("success", false).Msg("genregions")
		os.Exit(1)
	}
	log.Info().Bool("success", true).Msg("genregions")
	os.Exit(0)
}
